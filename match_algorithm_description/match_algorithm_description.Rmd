---
title: "Match algorithm description"
author: "Bruno Crotman"
date: "18/04/2020"
header-includes:
  - \usepackage{lscape}
  - \newcommand{\blandscape}{\begin{landscape}}
  - \newcommand{\elandscape}{\end{landscape}}  
  - \definecolor{darkred}{RGB}{150, 40, 40}
  - \definecolor{darkgreen}{RGB}{30, 120, 30}
output: 
    pdf_document:
        number_sections: true
        fig_caption: true

---



```{r setup, include=FALSE}

library(xml2)
library(tidyverse)
library(gt)
library(knitr)
library(kableExtra)

knitr::opts_chunk$set(echo = FALSE, size = "small", warning = FALSE, message = FALSE)

def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})


```

\section{Introduction}

This document is part of a bigger project. The project is a research about software degradation caused by careless developers' behavior and strategies to deal with it. The strategies to deal with the problem will possibly be inspired by concepts from game theory. At this moment, we think that software degradation can be measured by the number and the types of kludges made by software developers in the code. So, one of the goals of this project at this moment is to study how software projects evolve in terms of number of kludges and kinds of kludges.

Right now we are trying to identify kludges looking at alerts generated by PMD source code analyzer. This tool receives a programming code as input and generates a list of bad programming practices contained in the code.

In order to evaluate how the number of alerts is evolving along the history of a software project, we must be able to analyze two different versions of a code (an old version and a new version) and cateborize each alert as **new**, **fixed** or **not fixed**.

* each PMD alert generated for the old version is either **not fixed** or **fixed** in the new version. When an alert is **not fixed**, it means that it remains in the new version of the code. When an alert is **fixed**, it means that it does not exist anymore in the new version.

* each PMD alert generated for the new version is **not fixed** or **new**. When an alert is **not fixed** it means that the same alert was identified in the old version. When an alert is **new**, it means that the same alert cannot be identified in the old version.

The alerts identified as *not fixed* are the equivalent in both new and old versions. And the intersection between the *fixed* alerts, the *new* alerts and the *not fixed* alerts is empty.

In order to decide if an alert is *not fixed*, *fixed* or *new*, we have to identify if an alert in the old version is equivalent to an alert in the new version.

I describe here two algorithms. The first one, described in Section \ref{alg1}, is a naive algorithm based on matches by lines of code. The second is a more sophisticated algorithm, based on matches by blocks of code.

\section{Matches by line of code}\label{alg1}

In this first algorithm, I match the lines of code of the old version with the lines of code of the new version using information from the output of git's diff command. When an alert with the same features occurs in both matched lines, this alert is declared *not fixed*. The alerts that occur in a not matched line of the old version are declared *fixed* and the alerts located in a not matched line of the new version are declared *new*

These are the steps of the algorithm:

1. Generate a list of alerts from each version (old and new) using PMD Alert
1. Generate the git diff between the two versions
2. Using information from git diff, create a map between the lines
3. Categorize the alerts in *new*, *not fixed* or *fixed* 

\subsection{Generate a list of alerts for each version}\label{codes}


```{r definitions, cache=TRUE, echo=FALSE}

size_line_of_code <- 160

length_alert_name <- 35

length_alert_name_side_by_side <- 20

size_line_of_code_side_by_side <- 110


pmd_path <- "C:\\doutorado\\AnaliseTwitter4j\\pmd\\bin\\pmd.bat"

rule_path <- "rulesets/java/quickstart.xml"

output_path <-  "C:\\doutorado\\AnaliseTwitter4j\\match_algorithm_description\\"

examples <- tribble(
    
    ~name,                  ~path,                                                              ~output,          
    "Versão Old Original",  "C:\\doutorado\\AnaliseTwitter4j\\match_algorithm_description\\old" ,  "old_original",
    "Versão New 1",         "C:\\doutorado\\AnaliseTwitter4j\\match_algorithm_description\\new",   "new_1"
    
) %>% 
    mutate(id = row_number())

```

```{r alerts and maps functions, warning=FALSE, message=FALSE, echo=FALSE}

assemble_pmd_command <- function(pmd_path, code_path, rule_path, output_path, output){
    command <- str_glue("{pmd_path} -d {code_path} -f xml -R {rule_path} -reportfile {output_path}{output}.xml")
}

read_pmd_xml <- function(file){
    
    content_xml <- read_xml(file)
    
    
    alerts <- content_xml %>% 
        xml_children() %>% 
        xml_children() %>% 
        xml_attrs() %>% 
        map_df(.f = ~enframe(x = .x )) %>% 
        mutate(primeiro_campo = if_else(name == "beginline", 1, 0)  ) %>% 
        mutate(linha = cumsum(primeiro_campo) ) %>% 
        select(-primeiro_campo) %>% 
        pivot_wider(names_from = name, values_from = value) %>% 
        mutate(id_alert = row_number())

}


assemble_diff_command <- function(code_path_left, code_path_right, output_path, output_left, output_right){
    str_glue("git diff -U0 --patience --numstat --summary --output={output_path}{output_left}_{output_right}.diff --no-index {code_path_left} {code_path_right}")
}

read_number_of_lines <- function(dir){

    files <- list.files(dir)

    read_table(file = str_glue("{dir}\\{files}"), col_names = FALSE, skip_empty_rows = FALSE) %>% 
        nrow() 
}

map_lines <- function(file, lines_prev_param, lines_post_param){
    
    file <- "C:\\doutorado\\AnaliseTwitter4j\\match_algorithm_description\\old_original_new_1.diff"

    lines_prev_param <- as.integer(lines_prev_param)
    
    lines_post_param <- as.integer(lines_post_param)

    diff_marks <- read_table(file, col_names = FALSE ) %>% 
        rename(text = 1) %>% 
        mutate(
            marca_inicio_diff = str_detect(text, "diff --git"),
            id_diff = cumsum(marca_inicio_diff),
            diff_title = if_else(marca_inicio_diff, text, NA_character_)
        ) %>% 
        select(-marca_inicio_diff) %>% 
        fill(diff_title, .direction = "down") %>% 
        filter(str_starts(text, "@@")) %>% 
        separate(text, sep = " ", into = c("mark", "minus", "plus"), extra = "drop" ) %>% 
        select(-mark) %>% 
        separate(minus, into = c("line_remove", "n_remove"), sep = ",") %>% 
        separate(plus, into = c("line_add", "n_add"), sep = ",") %>% 
        mutate(
            n_remove = if_else(is.na(n_remove),"1",n_remove),
            n_add = if_else(is.na(n_add),"1",n_add)
        ) %>% 
        mutate(
            line_remove = str_remove(line_remove,"\\-") %>% str_trim(),
            line_add = str_remove(line_add,"\\+" %>% str_trim())
        ) %>% 
        separate(
            diff_title, 
            sep = " ", 
            into = 
                c(
                    "diff", 
                    "git", 
                    "file_prev",
                    "file_post"
                ), 
            extra = "drop" 
        ) %>% 
        select(c(-diff,-git)) %>% 
        mutate(
            file_post = str_replace(file_post, "b/",""),
            file_prev = str_replace(file_prev, "a/","")
        ) %>% 
        mutate(
            lines_prev = lines_prev_param,
            lines_post = lines_post_param
        ) %>%    
        mutate_at(
            vars(ends_with("_add")),
            as.integer
        ) %>% 
        mutate_at(
            vars(ends_with("_remove")),
            as.integer
        ) %>% 
        mutate(
            line_add = if_else(n_add == 0, line_add + 1L, line_add)
        ) %>% 
        mutate(
            end_remove = line_remove + n_remove - 1L,
            end_add = line_add + n_add - 1L
        ) %>% 
        mutate(
            line_remove = if_else(n_remove == 0 | is.na(n_remove) , line_remove+1L, line_remove ),
            end_remove = if_else(n_remove == 0 | is.na(n_remove) , end_remove+1L, end_remove )
        ) %>%
        group_by(id_diff) %>% 
        mutate(
            id_diff_id = row_number(),
            n_diff = n()
        ) %>% 
        ungroup() 
    
    
    last_diff <- diff_marks %>% 
        group_by(id_diff) %>% 
        summarise(
            line_remove = first(lines_prev) + 1L ,
            n_remove = NA,
            line_add = first(lines_post) + 1L ,
            n_add = NA,
            file_prev = first(file_prev),
            file_post = first(file_post),
            lines_prev = first(lines_prev),
            lines_post = first(lines_post),
            end_remove = NA,
            end_add = NA,
            id_diff_id = last(id_diff_id) + 1L,
            n_diff = first(n_diff)
        ) %>% 
        ungroup()
    
    map <- diff_marks %>% 
        bind_rows(last_diff) %>% 
        arrange(id_diff, id_diff_id) %>% 
        mutate(
            end_remove_prev = lag(end_remove),
            end_add_prev = lag(end_add)
        ) %>% 
        mutate(
            end_remove_prev = if_else(is.na(end_remove_prev),0L, end_remove_prev),
            end_add_prev = if_else(is.na(end_add_prev),0L, end_add_prev)
        ) %>% 
        mutate(
            line_add = if_else(is.na(line_add),0L, line_add)
        ) %>% 
        filter(!is.na(line_remove )) %>% 
        mutate(
            map_remove = map2(.x = (end_remove_prev + 1L), .y = (line_remove - 1L),.f = function(x, y) x:y),
            map_add = map2(.x = (end_add_prev+1L), .y = (line_add - 1L),.f = function(x, y) x:y)
        ) %>%
        filter(!is.na(lines_post)) %>%
        unnest(cols = c(map_remove, map_add )) %>% 
        select(
            lines_post,
            lines_prev,
            file_prev,
            file_post,
            map_remove,
            map_add
        ) 
    
    
    post_sem_prev <- diff_marks %>% 
        select(lines_post, file_post, file_prev) %>% 
        distinct() %>% 
        replace_na(list(lines_post = 1)) %>% 
        mutate( lines =  map(.x = lines_post, .f = function(x){tibble(map_add = 1:x)} )) %>% 
        unnest(lines) %>% 
        anti_join(map, by = c("file_post","map_add" )) 
    
    prev_sem_post <- diff_marks %>% 
        select(lines_prev, file_prev, file_post) %>% 
        distinct() %>% 
        replace_na(list(lines_prev = 1)) %>% 
        mutate( lines =  map(.x = lines_prev, .f = function(x){tibble(map_remove = 1:x)} )) %>% 
        unnest(lines) %>% 
        anti_join(map, by = c("file_post","map_remove" )) 
    
    
    
    final_map <- map %>%
        bind_rows(post_sem_prev) %>%
        bind_rows(prev_sem_post) %>% 
        mutate(
            changed = sum((is.na(map_remove) | is.na(map_add) ))
        ) %>% 
        rowwise() %>% 
        mutate(
            min_map = max(c(map_remove, map_add), na.rm = TRUE)
        ) %>%
        arrange(min_map)        
    
    
    

}


categorise_alerts <- function(map, alerts_old, alerts_new){
  
  map  = examples_crossed$lines_map[[1]]
  
  alerts_old = examples_executed$pmd_output[[1]] %>% 
    select(
      id_alert,
      line = beginline,
      rule,
      ruleset,
      package,
      class,
      method,
      variable
    ) %>% 
    rename_all(
      .funs = ~str_glue("{.x}_old")
    ) %>% 
    mutate(
      line_old = as.integer(line_old)
    )
  

  alerts_new = examples_executed$pmd_output[[2]] %>% 
    select(
      id_alert,
      line = beginline,
      rule,
      ruleset,
      package,
      class,
      method,
      variable
    ) %>% 
    rename_all(
      .funs = ~str_glue("{.x}_new")
    ) %>% 
    mutate(
      line_new = as.integer(line_new)
    )
    

  classification_old <- map %>% 
    select(
      line_old = map_remove,
      line_new = map_add,
    ) %>%
    mutate_all(
      as.integer
    ) %>% 
    left_join(
      alerts_old,
      by = c("line_old")
    ) %>% 
    left_join(
      alerts_new,
      by = c("line_new")
    ) %>% 
    filter(
      !is.na(rule_old)
    ) %>% 
    replace_na(
      list(
        rule_old = "No rule",
        rule_new = "No rule",
        class_new = "No class",
        class_old = "No class",
        ruleset_new = "No ruleset",
        ruleset_old = "no ruleset",
        class_old = "No class",
        class_new = "No class",
        method_old = "No method",
        method_new = "No method",
        variable_old = "No variable",
        variable_new = "No variable"
      )
    ) %>% 
    mutate(
      classification = if_else(
        rule_old == rule_new & 
          class_new == class_old & 
          method_old == method_new &
          variable_new == variable_old
          ,
        "Not fixed",
        "Fixed"
      )
    ) %>% 
    group_by(
      id_alert_old
    ) %>% 
    mutate(
      n_not_fixed = sum(classification == "Not fixed")
    ) %>% 
    filter(
      (n_not_fixed == 0) | classification == "Not fixed"
    ) 
  

  classification_new <- map %>% 
    select(
      line_old = map_remove,
      line_new = map_add,
    ) %>%
    mutate_all(
      as.integer
    ) %>% 
    left_join(
      alerts_old,
      by = c("line_old")
    ) %>% 
    left_join(
      alerts_new,
      by = c("line_new")
    ) %>% 
    filter(
      !is.na(rule_new)
    ) %>% 
    replace_na(
      list(
        rule_old = "No rule",
        rule_new = "No rule",
        class_new = "No class",
        class_old = "No class",
        ruleset_new = "No ruleset",
        ruleset_old = "no ruleset",
        class_old = "No class",
        class_new = "No class",
        method_old = "No method",
        method_new = "No method",
        variable_old = "No variable",
        variable_new = "No variable"
      )
    ) %>% 
    mutate(
      classification = if_else(
        rule_old == rule_new & 
          class_new == class_old & 
          method_old == method_new &
          variable_new == variable_old
          ,
        "Not fixed",
        "New"
      )
    ) %>% 
    group_by(
      id_alert_new
    ) %>% 
    mutate(
      n_not_fixed = sum(classification == "Not fixed")
    ) %>% 
    filter(
      (n_not_fixed == 0) | classification == "Not fixed"
    ) 

  classification <- bind_rows(
    classification_old %>% mutate(version = "Old"),
    classification_new %>% mutate(version = "New"),
  )
  
  classification
  
}


```

```{r execution of alerts and map, echo=FALSE  }


examples_executed <- examples %>% 
    mutate(
        pmd_command = 
            map2(
                .x = path, 
                .y = output, 
                ~assemble_pmd_command(
                    pmd_path = pmd_path, 
                    code_path = .x , 
                    rule_path = rule_path, 
                    output_path = output_path, 
                    output =.y
                )
            )
        ) %>% 
    mutate(
        pmd_command_output = map(.x = pmd_command, .f =  ~shell(cmd = .x, shell = "PowerShell"))
    ) %>% 
    mutate(
        pmd_output = map(.x = str_glue("{output_path}{output}.xml"), .f = read_pmd_xml )
    )

examples_executed_selected_fields_left <- examples_executed %>% select(id, name, path, output ) %>% 
    rename_all(.funs = function(x){str_glue("{x}_left")})

examples_executed_selected_fields_right <- examples_executed %>% select(id, name, path, output ) %>% 
    rename_all(.funs = function(x){str_glue("{x}_right")})


examples_crossed <- examples_executed_selected_fields_left %>%
    crossing(examples_executed_selected_fields_right) %>%
    filter(
        id_left < id_right
    ) %>% 
    mutate(
        diff_command = 
            map2(
                .x = path_left, 
                .y = path_right, 
                ~assemble_diff_command(
                    code_path_left = .x, 
                    code_path_right = .y, 
                    output_path = output_path, 
                    output_left = output_left, 
                    output_right = output_right
                )
            )
    ) %>% 
    mutate(
        lines_left = read_number_of_lines(path_left),
        lines_right = read_number_of_lines(path_right)
    ) %>% 
    mutate(
        output_diff_command = map(.x = diff_command, .f = ~shell(cmd = .x, shell = "PowerShell")),
        file_diff = str_glue("{output_path}{output_left}_{output_right}.diff")
    ) %>% 
    mutate(
        lines_map = pmap(
          .l = list(
            file = file_diff  , 
            lines_prev_param = lines_left, 
            lines_post_param = lines_right
          ), 
          .f = map_lines  
        )
    )
    



```

```{r decoration functions, echo=FALSE}

decorate_code <- function(strings){
    strings %>% 
        enframe(name = "line", value = "code") %>% 
        mutate(
            line = as.character(line) %>%  str_pad(width = 3, side = "left"),
            code = code %>%  str_trunc(width = size_line_of_code, ellipsis = "..."),
             final_code = str_glue("/*{line}*/{code}") 
        ) %>% 
        pull(final_code)
}


aggregate_alerts_by_line <- function(alerts, trunc_rule_length_param = NA_real_){

  
  trunc_rule_length <- if_else(is.na(trunc_rule_length_param), 10, trunc_rule_length_param)

  alerts %>% 
    mutate(
        beginline = as.integer(beginline)
    ) %>% 
    group_by(
        beginline,
        rule
    ) %>% 
    summarise(
        n = n()
    ) %>%
    mutate(
      rule = if_else(
        is.na(trunc_rule_length_param), 
        rule, 
        str_trunc(rule, width = trunc_rule_length, side = "right", ellipsis = "") %>% as.character()
      )
    ) %>% 
    mutate(
        rule = if_else(n == 1, rule, str_glue("{rule}({n})") %>% as.character()  )
    )

}

decorate_code_and_alerts <- function(strings, alerts){

  # for debug
  # strings <- read_lines("old/code.java")
  # alerts <- examples_executed$pmd_output[[1]]
  

  alert <- alerts %>%
      as_tibble() %>% 
      select(beginline, rule) %>%
      aggregate_alerts_by_line()
    


  max_rule <- alert %>% 
      pull(rule) %>% 
      str_length() %>% 
      max(na.rm = TRUE)
      
  
  strings %>% 
      enframe(name = "line", value = "code") %>% 
      left_join(
          alert,
          by = c("line" = "beginline")
      ) %>% 
      replace_na(
          list(rule = "")
      ) %>% 
      mutate(
          line = as.character(line) %>%  str_pad(width = 3, side = "left"),
          code = code %>%  str_trunc(width = size_line_of_code - length_alert_name, ellipsis = "..."),
          rule = rule %>% str_pad(width = length_alert_name, side = "right" ),
          final_code = str_glue("/*{line}-{rule}*/{code}") 
      ) %>% 
      pull(final_code) 
}


decorate_code_alerts_mapped <- function(strings_old_param, alerts_old_param, strings_new_param, alerts_new_param, map_param){

  # for debug
  # strings_old_param <-  read_lines("old/code.java")
  # strings_new_param <-  read_lines("new/code.java")
  # alerts_old_param <-  examples_executed$pmd_output[[1]] 
  # alerts_new_param <-  examples_executed$pmd_output[[2]] 
  # map_param <-  examples_crossed$lines_map[[1]]
  
  

  map <- map_param %>%
    select(
      line_old = map_remove,
      line_new = map_add
    )

  strings_old <- strings_old_param %>% enframe(name = "line_old", value = "code_old") %>% replace_na(list(code_old = ""))

  alerts_old <- alerts_old_param %>%
    aggregate_alerts_by_line(trunc_rule_length = length_alert_name_side_by_side) %>%
    select(line_old = beginline, rule_old = rule ) 

  strings_new <- strings_new_param %>% enframe(name = "line_new", value = "code_new") %>% replace_na(list(code_new = ""))

  alerts_new <- alerts_new_param %>%
    aggregate_alerts_by_line(trunc_rule_length = length_alert_name_side_by_side) %>%
    select(line_new = beginline, rule_new = rule )


  saida <- map %>%
    left_join(
      strings_old,
      by = c("line_old")
    ) %>%
    left_join(
      alerts_old,
      by = c("line_old")
    ) %>%
    left_join(
      strings_new,
      by = c("line_new")
    ) %>%
    left_join(
      alerts_new,
      by = c("line_new")
    ) %>%
    mutate(
      line_old = as.character(line_old),
      line_new = as.character(line_new)
    ) %>% 
    replace_na(
      list(
        code_new = "/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/",
        code_old = "/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/",
        line_old = "",
        line_new = "",
        code_old = "",
        code_new = "",
        rule_old = "",
        rule_new = ""
      )
    ) %>%
    mutate(
      line_old = line_old %>%  str_pad(width = 3, side = "left"),
      line_new = line_new %>%  str_pad(width = 3, side = "left"),
      code_old = code_old %>%  
        str_trunc(width = size_line_of_code_side_by_side - length_alert_name_side_by_side, ellipsis = "") %>% 
        str_pad(width = size_line_of_code_side_by_side - length_alert_name_side_by_side, side = "right"),
      
      code_new = code_new %>%  
        str_trunc(width = size_line_of_code_side_by_side - length_alert_name_side_by_side, ellipsis = "") %>%  
        str_pad(width = size_line_of_code_side_by_side - length_alert_name_side_by_side, side = "right"),
      
      rule_old = rule_old %>% str_pad(width = length_alert_name_side_by_side + 3, side = "right" ),
      rule_new = rule_new %>% str_pad(width = length_alert_name_side_by_side + 3, side = "right" ),
      final_code = str_glue("/*{line_old}-{rule_old}*/{code_old}/*{line_new}-{rule_new}*/{code_new}")
    ) %>%
    pull(final_code)

  

}


read_and_decorate_code <-  function(file){
    read_lines(file, ) %>% 
        decorate_code() %>% 
        as.character()
}



read_and_decorate_code_and_alerts <-  function(file, alerts){
  
  #for debug
  # file <-  "old/code.java"
  # alerts <- examples_executed$pmd_output[[1]]

  read_lines(file) %>% 
      decorate_code_and_alerts(alerts = alerts) %>% 
      as.character()
}



read_and_decorate_code_and_alerts_mapped <-  function(file_old, alerts_old, file_new, alerts_new, map){

  # For debug
  # file_old <- "old/code.java"
  # alerts_old <- examples_executed$pmd_output[[1]] 
  # file_new <-  "new/code.java"
  # alerts_new <- examples_executed$pmd_output[[2]]
  # map <- examples_crossed$lines_map[[1]]

  strings_new <- read_lines(file_new)
  strings_old <- read_lines(file_old)
  
  decorate_code_alerts_mapped(
    strings_old_param = strings_old,
    strings_new_param = strings_new,
    alerts_old_param = alerts_old,
    alerts_new_param = alerts_new,
    map_param = map
  ) %>% 
    as.character() 
  
}


```

The two codes presented in this Section, named "new version" and "old version", are used in Sections \ref{diff}, \ref{map} and \ref{categorize} to describe the algorithm.

The old version, with the alerts generated by PMI, is shown below.

\newpage

\blandscape


```{java code old, code=read_and_decorate_code_and_alerts("old/code.java", examples_executed$pmd_output[[1]]), echo = TRUE }

```

\elandscape

\newpage

Table \ref{alerts_old} lists the alerts found in the old version.

```{r  show alerts old, echo=FALSE }

examples_executed$pmd_output[[1]] %>% 
  select(
    id = id_alert,
    beginline,
    ruleset,
    rule,
    package,
    class,
    method,
    variable
  ) %>% 
  replace_na(
    list(
      method = "No method",
      variable = "No variable"
    )
  ) %>% 
  kable(
    caption = "Alerts in the old version\\label{alerts_old}",
  ) %>% 
  kable_styling(
    font_size = 6,  
    latex_options = c("hold_position")
  )
  


```


The new version has the following changes in relation to the old version: 

* line 24 of the old version "import java.util.concurrent.ConcurrentHashMap", that was a "Unused Import", was removed. So the alert related to this line must be declared *fixed*.
* line 92 of the old version (91 of the new version) was fixed by changing the name of the parameter. This must be classified as another *fixed* alert.
* line 119 was included in the new version, with an unused private field. This must be categorized as a *new* alert

\newpage

\blandscape

```{java new code, code=read_and_decorate_code_and_alerts("new/code.java", examples_executed$pmd_output[[2]]), echo=TRUE }


```

\elandscape

Table \ref{alerts_new} lists the alerts found in the new version.

```{r  show alerts new, echo=FALSE }

examples_executed$pmd_output[[2]] %>% 
  select(
    id = id_alert,
    beginline,
    ruleset,
    rule,
    package,
    class,
    method,
    variable
  ) %>% 
  replace_na(
    list(
      method = "No method",
      variable = "No variable"
    )
  ) %>% 
  kable(
    caption = "Alerts in the new version\\label{alerts_new}",
  ) %>% 
  kable_styling(
    font_size = 6,
    latex_options = c("hold_position")
  )
  


```


    
\subsection{Generate the git diff between the two versions}\label{diff}

The command git diff is executed between the two versions with the option --patience. 

The result of the git diff operation between this two versions is shown below:


```{diff showing git diff,  code=readLines("old_original_new_1.diff"), echo=TRUE}


```


\subsection{Using information from git diff, create a map between the lines}\label{map}


Using this information from git's diff, it's possible to create a map between the lines of the old version and the new version.

For each difference stated in the git diff output (the sections of the diff file starting with "@@"), there is an indication of the number of lines removed from the old version and the number of lines added to the new version. The line in which the lines are removed from the old version and the line at which the lines are added is indicated, too.  Following this information it´s possible to create a map between the lines of the old version and the equivalent lines in the new version.

For the new and old versions presented in Section \ref{codes}, the map is shown in Table \ref{table_map}


```{r showing map  }

examples_crossed$lines_map[[1]] %>% 
  ungroup() %>% 
  mutate(
    row = row_number(),
    na_mark = if_else(is.na(map_remove) | is.na(map_add), row , NA_integer_  ),
    next_na = na_mark,
    last_na = na_mark
  ) %>% 
  fill(
    next_na, .direction = "up"
  ) %>% 
  fill(
    last_na, .direction = "down"
  ) %>% 
  replace_na(
    list(
      last_na = 0,
      next_na = nrow(examples_crossed$lines_map[[1]]) + 1
    )
  ) %>%
  mutate(
    dist_next = next_na - row,
    dist_last = row - last_na 
  ) %>%
  rowwise() %>% 
  mutate(
    min_dist = min(dist_next, dist_last)
  ) %>% 
  filter(
    min_dist < 4
  ) %>%
  mutate(
    map_remove = if_else(min_dist == 3, "...", as.character(map_remove) ),
    map_add = if_else(min_dist == 3, "...", as.character(map_add) )
  ) %>% 
  select(old = map_remove, new = map_add) %>% 
  kable(
    longtable = TRUE,
    caption = "Map between lines of the old version and lines of the new version\\label{table_map}"
  ) %>% 
  kable_styling(
    latex_options = c("repeat_header")
  ) 


```



\newpage

\blandscape


Now we can connect the to versions and plugin the alerts



```{java showing codes, code=read_and_decorate_code_and_alerts_mapped("old/code.java", examples_executed$pmd_output[[1]], "new/code.java", examples_executed$pmd_output[[2]],examples_crossed$lines_map[[1]]), echo=TRUE, size="tiny"  }

```

\elandscape

\newpage 

\subsection{Categorize the alerts}\label{categorize}

The alert in the old version is classified as **not fixed** if there is an alert in the new version in the corresponding line with the same rule, same method name and same variable name. Otherwise, the alert is categorised as **fixed**

Table \ref{class_old} shows the classification of the alerts in the old version. The alerts 1 and 4

```{r executing classifications, echo=FALSE}

classifications <- categorise_alerts(
  map = examples_crossed$lines_map[[1]], 
  alerts_old = examples_executed$pmd_output[[1]],
  alerts_new = examples_executed$pmd_output[[2]]
  ) 


```


```{r}

classifications_to_show <- classifications %>% 
  filter(version == "Old" ) %>% 
  select(
    id = id_alert_old,
    line = line_old,
    rule = rule_old,
    class = class_old,
    method = method_old,
    variable = variable_old,
    idnew = id_alert_new,
    linenew = line_new, 
    category = classification
  ) %>% 
  ungroup() %>% 
  mutate_if(
    is.character,
    ~str_replace_all(.x, "\\_", "\\\\_") 
  )

classifications_to_show %>% 
  mutate(
    category = cell_spec(x = category, format = "latex", color = if_else(category == "Fixed", "darkgreen", "darkred"))
  ) %>%
  kable(
    format = "latex",
    caption = "Classifications of the alerts in the old version",
    escape = FALSE,
    booktabs = TRUE,
    linesep = ""
  ) %>%
  kable_styling(
    font_size = 6,
    latex_options = c("hold_position", "striped")
  )
  
  


```







