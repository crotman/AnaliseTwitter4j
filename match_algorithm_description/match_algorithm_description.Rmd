---
title: "Match algorithm description"
author: "Bruno Crotman"
date: "18/04/2020"
output: 
    pdf_document:
        number_sections: true
        fig_caption: true

---

```{r setup, include=FALSE}

library(xml2)
library(tidyverse)
library(gt)

size_line_of_code <- 160

length_alert_name <- 35

knitr::opts_chunk$set(echo = TRUE, size = "tiny")

def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})


```

\section{Introduction}

The goal is to analyze two different versions of a code (an old version and a new version) and decide if 

* each PMD alert generated for the old version is *not fixed* or *fixed* in the new version. When an alert is *not fixed*, it means that it remains in the new version. When an alert is *fixed*, it means that it does not exist anymore in the new version.

* each PMD alert generated for the new version is *not fixed* or *new*. When an alert is *not fixed* it means that the same alert was identified in the old version. When an alert is *new*, it means that the same alert was not identified in the old version.

The alerts identified as *not fixed* are the same in both new and old versions. And the intersection between the *fixed* alerts, the *new* alerts and the *not fixed* alerts is empty.

In order to decide if an alert is *not fixed*, *fixed* or *new*, I must identify if an alert in the old version is equivalent to an alert in the new version.

I describe here two algorithms. The first is a naive algorithm based on matches by lines of code, it was the first to be implemented. The second is a more sophisticated algorithm, based on matches by blocks of code. The second one is not implemented yet.

\section{Matches by line of code}

In this first algorithm, I match the lines of code of the old version with the lines of code of the new version using information from the output of git's diff command. When an alert of the same kind occurs in both matched lines, this alert is declared *not fixed*. The alerts that occur in a not matched line of the old version is declared *fixed* and

```{r, cache=TRUE, echo=FALSE}


pmd_path <- "C:\\doutorado\\AnaliseTwitter4j\\pmd\\bin\\pmd.bat"

rule_path <- "rulesets/java/quickstart.xml"

output_path <-  "C:\\doutorado\\AnaliseTwitter4j\\match_algorithm_description\\"

examples <- tribble(
    
    ~name,                  ~path,                                                              ~output,          
    "Versão Old Original",  "C:\\doutorado\\AnaliseTwitter4j\\match_algorithm_description\\old" ,  "old_original",
    "Versão New 1",         "C:\\doutorado\\AnaliseTwitter4j\\match_algorithm_description\\new",   "new_1"
    
) %>% 
    mutate(id = row_number())

```




```{r, warning=FALSE, message=FALSE, echo=FALSE}

assemble_pmd_command <- function(pmd_path, code_path, rule_path, output_path, output){
    command <- str_glue("{pmd_path} -d {code_path} -f xml -R {rule_path} -reportfile {output_path}{output}.xml")
}

read_pmd_xml <- function(file){
    
    content_xml <- read_xml(file)
    
    
    alerts <- content_xml %>% 
        xml_children() %>% 
        xml_children() %>% 
        xml_attrs() %>% 
        map_df(.f = ~enframe(x = .x )) %>% 
        mutate(primeiro_campo = if_else(name == "beginline", 1, 0)  ) %>% 
        mutate(linha = cumsum(primeiro_campo) ) %>% 
        select(-primeiro_campo) %>% 
        pivot_wider(names_from = name, values_from = value) %>% 
        mutate(id_alert = row_number())

}



examples_executed <- examples %>% 
    mutate(
        pmd_command = 
            map2(
                .x = path, 
                .y = output, 
                ~assemble_pmd_command(
                    pmd_path = pmd_path, 
                    code_path = .x , 
                    rule_path = rule_path, 
                    output_path = output_path, 
                    output =.y
                )
            )
        ) %>% 
    mutate(
        pmd_command_output = map(.x = pmd_command, .f =  ~shell(cmd = .x, shell = "PowerShell"))
    ) %>% 
    mutate(
        pmd_output = map(.x = str_glue("{output_path}{output}.xml"), .f = read_pmd_xml )
    )

examples_executed_selected_fields_left <- examples_executed %>% select(id, name, path, output ) %>% 
    rename_all(.funs = function(x){str_glue("{x}_left")})

examples_executed_selected_fields_right <- examples_executed %>% select(id, name, path, output ) %>% 
    rename_all(.funs = function(x){str_glue("{x}_right")})


assemble_diff_command <- function(code_path_left, code_path_right, output_path, output_left, output_right){
    str_glue("git diff -U0 --patience --numstat --summary --output={output_path}{output_left}_{output_right}.diff --no-index {code_path_left} {code_path_right}")
}

read_number_of_lines <- function(dir){

    files <- list.files(dir)

    read_table(file = str_glue("{dir}\\{files}"), col_names = FALSE, skip_empty_rows = FALSE) %>% 
        nrow() 
}



map_lines <- function(file, lines_prev_param, lines_post_param){
    
    file <- "C:\\doutorado\\AnaliseTwitter4j\\match_algorithm_description\\old_original_new_1.diff"

    lines_prev_param <- as.integer(lines_prev_param)
    
    lines_post_param <- as.integer(lines_post_param)

    diff_marks <- read_table(file, col_names = FALSE ) %>% 
        rename(text = 1) %>% 
        mutate(
            marca_inicio_diff = str_detect(text, "diff --git"),
            id_diff = cumsum(marca_inicio_diff),
            diff_title = if_else(marca_inicio_diff, text, NA_character_)
        ) %>% 
        select(-marca_inicio_diff) %>% 
        fill(diff_title, .direction = "down") %>% 
        filter(str_starts(text, "@@")) %>% 
        separate(text, sep = " ", into = c("mark", "minus", "plus"), extra = "drop" ) %>% 
        select(-mark) %>% 
        separate(minus, into = c("line_remove", "n_remove"), sep = ",") %>% 
        separate(plus, into = c("line_add", "n_add"), sep = ",") %>% 
        mutate(
            n_remove = if_else(is.na(n_remove),"1",n_remove),
            n_add = if_else(is.na(n_add),"1",n_add)
        ) %>% 
        mutate(
            line_remove = str_remove(line_remove,"\\-") %>% str_trim(),
            line_add = str_remove(line_add,"\\+" %>% str_trim())
        ) %>% 
        separate(
            diff_title, 
            sep = " ", 
            into = 
                c(
                    "diff", 
                    "git", 
                    "file_prev",
                    "file_post"
                ), 
            extra = "drop" 
        ) %>% 
        select(c(-diff,-git)) %>% 
        mutate(
            file_post = str_replace(file_post, "b/",""),
            file_prev = str_replace(file_prev, "a/","")
        ) %>% 
        mutate(
            lines_prev = lines_prev_param,
            lines_post = lines_post_param
        ) %>%    
        mutate_at(
            vars(ends_with("_add")),
            as.integer
        ) %>% 
        mutate_at(
            vars(ends_with("_remove")),
            as.integer
        ) %>% 
        mutate(
            line_add = if_else(n_add == 0, line_add + 1L, line_add)
        ) %>% 
        mutate(
            end_remove = line_remove + n_remove - 1L,
            end_add = line_add + n_add - 1L
        ) %>% 
        mutate(
            line_remove = if_else(n_remove == 0 | is.na(n_remove) , line_remove+1L, line_remove ),
            end_remove = if_else(n_remove == 0 | is.na(n_remove) , end_remove+1L, end_remove )
        ) %>%
        group_by(id_diff) %>% 
        mutate(
            id_diff_id = row_number(),
            n_diff = n()
        ) %>% 
        ungroup() 
    
    
    last_diff <- diff_marks %>% 
        group_by(id_diff) %>% 
        summarise(
            line_remove = first(lines_prev) + 1L ,
            n_remove = NA,
            line_add = first(lines_post) + 1L ,
            n_add = NA,
            file_prev = first(file_prev),
            file_post = first(file_post),
            lines_prev = first(lines_prev),
            lines_post = first(lines_post),
            end_remove = NA,
            end_add = NA,
            id_diff_id = last(id_diff_id) + 1L,
            n_diff = first(n_diff)
        ) %>% 
        ungroup()
    
    map <- diff_marks %>% 
        bind_rows(last_diff) %>% 
        arrange(id_diff, id_diff_id) %>% 
        mutate(
            end_remove_prev = lag(end_remove),
            end_add_prev = lag(end_add)
        ) %>% 
        mutate(
            end_remove_prev = if_else(is.na(end_remove_prev),0L, end_remove_prev),
            end_add_prev = if_else(is.na(end_add_prev),0L, end_add_prev)
        ) %>% 
        mutate(
            line_add = if_else(is.na(line_add),0L, line_add)
        ) %>% 
        filter(!is.na(line_remove )) %>% 
        mutate(
            map_remove = map2(.x = (end_remove_prev + 1L), .y = (line_remove - 1L),.f = function(x, y) x:y),
            map_add = map2(.x = (end_add_prev+1L), .y = (line_add - 1L),.f = function(x, y) x:y)
        ) %>%
        filter(!is.na(lines_post)) %>%
        unnest(cols = c(map_remove, map_add )) %>% 
        select(
            lines_post,
            lines_prev,
            file_prev,
            file_post,
            map_remove,
            map_add
        ) 
    
    
    post_sem_prev <- diff_marks %>% 
        select(lines_post, file_post, file_prev) %>% 
        distinct() %>% 
        replace_na(list(lines_post = 1)) %>% 
        mutate( lines =  map(.x = lines_post, .f = function(x){tibble(map_add = 1:x)} )) %>% 
        unnest(lines) %>% 
        anti_join(map, by = c("file_post","map_add" )) 
    
    prev_sem_post <- diff_marks %>% 
        select(lines_prev, file_prev, file_post) %>% 
        distinct() %>% 
        replace_na(list(lines_prev = 1)) %>% 
        mutate( lines =  map(.x = lines_prev, .f = function(x){tibble(map_remove = 1:x)} )) %>% 
        unnest(lines) %>% 
        anti_join(map, by = c("file_post","map_remove" )) 
    
    
    
    final_map <- map %>%
        bind_rows(post_sem_prev) %>%
        bind_rows(prev_sem_post) %>% 
        mutate(
            changed = sum((is.na(map_remove) | is.na(map_add) ))
        ) %>% 
        rowwise() %>% 
        mutate(
            min_map = max(c(map_remove, map_add), na.rm = TRUE)
        ) %>%
        arrange(min_map)        
    
    
    

}


examples_crossed <- examples_executed_selected_fields_left %>%
    crossing(examples_executed_selected_fields_right) %>%
    filter(
        id_left < id_right
    ) %>% 
    mutate(
        diff_command = 
            map2(
                .x = path_left, 
                .y = path_right, 
                ~assemble_diff_command(
                    code_path_left = .x, 
                    code_path_right = .y, 
                    output_path = output_path, 
                    output_left = output_left, 
                    output_right = output_right
                )
            )
    ) %>% 
    mutate(
        lines_left = read_number_of_lines(path_left),
        lines_right = read_number_of_lines(path_right)
    ) %>% 
    mutate(
        output_diff_command = map(.x = diff_command, .f = ~shell(cmd = .x, shell = "PowerShell")),
        file_diff = str_glue("{output_path}{output_left}_{output_right}.diff")
    ) %>% 
    mutate(
        lines_map = pmap(.l = list(file = file_diff  , lines_prev_param = lines_left, lines_post_param = lines_right), .f = map_lines  )
    )
    


```

```{r, echo=FALSE}

decorate_code <- function(strings){
    strings %>% 
        enframe(name = "line", value = "code") %>% 
        mutate(
            line = as.character(line) %>%  str_pad(width = 3, side = "left"),
            code = code %>%  str_trunc(width = size_line_of_code, ellipsis = "..."),
             final_code = str_glue("/*{line}*/{code}") 
        ) %>% 
        pull(final_code)
}


aggregate_alerts_by_line <- function(alerts){

  alerts %>% 
        mutate(
            beginline = as.integer(beginline)
        ) %>% 
        group_by(
            beginline,
            rule
        ) %>% 
        summarise(
            n = n()
        ) %>% 
        mutate(
            rule = if_else(n == 1, rule, str_glue("{rule}({n})") %>% as.character()  )
        )

}

decorate_code_and_alerts <- function(strings, alerts){

    alert <- alerts %>%
        as_tibble() %>% 
        select(beginline, rule) %>%
        aggregate_alerts_by_line()
      


    max_rule <- alert %>% 
        pull(rule) %>% 
        str_length() %>% 
        max(na.rm = TRUE)
        
    
    strings %>% 
        enframe(name = "line", value = "code") %>% 
        left_join(
            alert,
            by = c("line" = "beginline")
        ) %>% 
        replace_na(
            list(rule = "")
        ) %>% 
        mutate(
            line = as.character(line) %>%  str_pad(width = 3, side = "left"),
            code = code %>%  str_trunc(width = size_line_of_code - length_alert_name, ellipsis = "..."),
            rule = rule %>% str_pad(width = length_alert_name, side = "right" ),
            final_code = str_glue("/*{line}-{rule}*/{code}") 
        ) %>% 
        pull(final_code) 
}


decorate_code_alerts_mapped <- function(strings_old_param, alerts_old_param, strings_new_param, alerts_new_param, map_param){


  map <- map_param %>%
    select(
      line_old = map_remove,
      line_new = map_add
    )

  strings_old <- strings_old_param %>% enframe(name = "line_old", value = "code_old") %>% replace_na(list(code_old = ""))

  alerts_old <- alerts_old_param %>%
    aggregate_alerts_by_line() %>%
    select(line_old = beginline, rule_old = rule )

  strings_new <- strings_new_param %>% enframe(name = "line_new", value = "code_new") %>% replace_na(list(code_new = ""))

  alerts_new <- alerts_new_param %>%
    aggregate_alerts_by_line() %>%
    select(line_new = beginline, rule_new = rule )


  saida <- map %>%
    left_join(
      strings_old,
      by = c("line_old")
    ) %>%
    left_join(
      alerts_old,
      by = c("line_old")
    ) %>%
    left_join(
      strings_new,
      by = c("line_new")
    ) %>%
    left_join(
      alerts_new,
      by = c("line_new")
    ) %>%
    mutate(
      line_old = as.character(line_old),
      line_new = as.character(line_new)
    ) %>% 
    replace_na(
      list(
        code_new = "/*XXXXXXXXXXXXXXXXX*/",
        code_old = "/*XXXXXXXXXXXXXXXXX*/",
        line_old = "",
        line_new = "",
        code_old = "",
        code_new = "",
        rule_old = "",
        rule_new = ""
      )
    ) %>%
    mutate(
      line_old = line_old %>%  str_pad(width = 3, side = "left"),
      line_new = line_new %>%  str_pad(width = 3, side = "left"),
      code_old = code_old %>%  
        str_trunc(width = size_line_of_code/2 - length_alert_name, ellipsis = "") %>% 
        str_pad(size_line_of_code/2 - length_alert_name, side = "right"),
      
      code_new = code_new %>%  
        str_trunc(width = size_line_of_code/2 - length_alert_name, ellipsis = "") %>%  
        str_pad(width = size_line_of_code/2 - length_alert_name, side = "right"),
      
      rule_old = rule_old %>% str_pad(width = length_alert_name, side = "right" ),
      rule_new = rule_new %>% str_pad(width = length_alert_name, side = "right" ),
      final_code = str_glue("/*{line_old}-{rule_old}*/{code_old}/*{line_new}-{rule_new}*/{code_new}")
    ) %>%
    pull(final_code)

  

}


read_and_decorate_code <-  function(file){
    read_lines(file, ) %>% 
        decorate_code() %>% 
        as.character()
}



read_and_decorate_code_and_alerts <-  function(file, alerts){
    read_lines(file) %>% 
        decorate_code_and_alerts(alerts = alerts) %>% 
        as.character()
}



read_and_decorate_code_and_alerts_mapped <-  function(file_old, alerts_old, file_new, alerts_new, map){
    strings_new <- read_lines(file_new)
    strings_old <- read_lines(file_old)
    
    decorate_code_alerts_mapped(
      strings_old_param = strings_old,
      strings_new_param = strings_new,
      alerts_old_param = alerts_old,
      alerts_new_param = alerts_new,
      map_param = map
    ) %>% 
      as.character() 
  
}


```


The old version, with the alerts generated by PMI, is the following code


```{java code=read_and_decorate_code_and_alerts("old/code.java", examples_executed$pmd_output[[1]]) }

```


The new version is the following code: 

* line 24 of the old version "import java.util.concurrent.ConcurrentHashMap", that was a "Unused Import", was removed. 
* line 92 of the old version (91 of the new version) was fixed by changing the name of the parameter
* line 119 was included in the new version, with an unused private field.


```{java code=read_and_decorate_code_and_alerts("new/code.java", examples_executed$pmd_output[[2]]) }


```
    
The result of the git diff operation upon this two versions is this:


```{diff code=readLines("old_original_new_1.diff")}


```


Using this information from git's diff, it's possible to create a map between the lines of the old version and the new version:


```{r}

examples_crossed$lines_map[[1]] %>% 
  select(old = map_remove, new = map_add) %>% 
  gt() %>% 
  tab_header(title = "Lines map", subtitle = "Map between lines in the old version and in te new version")


```


Now we can connect the to versions and plugin the alerts



```{java code=read_and_decorate_code_and_alerts_mapped("old/code.java", examples_executed$pmd_output[[1]], "new/code.java", examples_executed$pmd_output[[2]],examples_crossed$lines_map[[1]])  }

```








