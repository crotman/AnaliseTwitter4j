---
title: "PMD alerts as possible kludges: open, fixed or new?"
author: "Bruno Crotman"
header-includes:
  - \usepackage{lscape}
  - \newcommand{\blandscape}{\begin{landscape}}
  - \newcommand{\elandscape}{\end{landscape}}  
  - \definecolor{darkred}{RGB}{150, 40, 40}
  - \definecolor{darkgreen}{RGB}{30, 120, 30}
  - \definecolor{darkorange}{RGB}{40, 40, 160}
output: 
    pdf_document:
        number_sections: true
        fig_caption: true
        toc: true
        toc_depth: 3 

---



```{r setup, include=FALSE}

library(xml2)
library(tidyverse)
library(gt)
library(knitr)
library(kableExtra)
library(tidygraph)
library(ggraph)
library(patchwork)
library(magrittr)
library(scales)
library(magrittr)

knitr::opts_chunk$set(echo = FALSE, size = "small", warning = FALSE, message = FALSE, cache = FALSE)

def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})


map_rule_small <- tribble(
    
    ~rule,                              ~small_rule,
    "class_or_interface_body",          "class_body",                   
    "class_or_interface_declaration",   "class_decl",
      "class_or_interface_type",          "class_type",
    "compilation_unit",                 "unit",
    "extends_list",                     "extends",
    "implements_list",                  "implements",
    "import_declaration",               "import",
    "method",                           "method",
    "name",                             "name",
    "package",                          "package",
    "type_declaration",                 "type_decl",
    "constructor_declaration",          "constructor",
    "field_declaration",                "field",
    "variable_id",                      "var_id",
    "formal_parameter",                 "param",
    "formal_parameters",                "params",
    "annotation",                       "annotation",
    "block",                            "block",
    "statement",                        "statement",
    "if_statement",                     "if"

)

 

source("match_alerts_app/R/functions.r", encoding = "UTF-8") 


```



```{r definitions, echo=FALSE}

size_line_of_code <- 160

length_alert_name <- 35

length_alert_name_side_by_side <- 14

size_line_of_code_side_by_side <- 77


pmd_path <- "pmd/bin/pmd.bat"

rule_path <- "rulesets/java/quickstart.xml"

output_path <-  ""  

examples <- tribble(
    
    ~name,                  ~path,                                                              ~output,          
    "Versão Old Original",  "old" ,  "old_original",
    "Versão New 1",         "new",   "new_1"
    
) %>% 
    mutate(id = row_number())

```


\section{Introduction}\label{intro}

This document is part of a larger research project about software degradation caused by careless developers' behavior and strategies to deal with such undesired behavior. 
The strategies to deal with this problem will possibly be inspired by concepts from game theory. 
At this moment, we assume that software degradation can be measured by the number and the types of kludges made by software developers in the code. 
So, one of the goals of this project is to study how software projects evolve in terms of number and kinds of kludges. 
Right now, we are trying to identify kludges by looking at alerts generated by the PMD source code analyzer.

To evaluate how the number of alerts evolves throughout the history of a software project, we must be able to analyze two different versions of a source code (an old and a new version) and categorize each alert contained in the new version as either **new**, **fixed** or **open**.

A PMD alert generated for the old version is either **open** or **fixed** in the new version. 
An **open** alert remains in the new version of the code. 
A **fixed** alert does not exist in the new version. 

A PMD alert generated for the new version is either **open** or **new**. 
An **open** alert indicates that the same alert was identified in the old version. 
A **new** alert implies that the same alert cannot be identified in the old version. 

The alerts identified as **open** are equivalent in both new and old versions. 
To decide whether an alert is **open**, **fixed** or **new**, one has to identify if an alert in the old version is equivalent to an alert in the new version. 
The intersection between **fixed** alerts, **new** alerts and **open** alerts is empty. 

In order to decide if an alert is **open**, **fixed** or **new**, we have to identify if an alert in the old version is equivalent to an alert in the new version. 
This document describes the algorithms we are using to make this classification.  

In Section \ref{pmd}, we describe how we use PMD source code analyzer in two tasks:

\begin{itemize}
\item The first task is to list the alerts that represent possible kludges. 
PMD receives a source code as input and generates a list of bad programming practices contained in the code, i.e., the alerts. 
The process we follow to generate the alerts using PMD source code analyzer is discussed in Section \ref{pmd_alerts}. 
\item The second task for which we use PMD is in the creation of an Abstract Syntax Tree (AST) from a source code, with selected nodes. 
This will help us in the algorithm described in Section \ref{alg2}. 
The creation of the AST using PMD is described in Section \ref{ast}.
\end{itemize}

In Section \ref{alg}, we describe two algorithms that help to categorize the alerts as **new**, **fixed** or **open**. 
The first one, described in Section \ref{alg1}, is a naive algorithm based on matches by lines of code and some key features of the alerts. 
The second is a more sophisticated algorithm, based on matches by blocks of code, using the Abstract Syntax Tree.


\section{PMD Source Code Analyzer}\label{pmd}

PMD is static source code analyzer that is commonly used to find possible programming flaws. 
In this work we use PMD for two tasks: to generate alerts that we interpret as clues about kludges and to create an AST from the source code with selected kinds of node.

\subsection{Using PMD to generate alerts}\label{pmd_alerts}

PMD traverses the AST of a source code searching for violations of rules which are configured by the user. 
PMD comes with a default rule set for Java language. 
The default rule set finds common programming flaws like unused variables, empty catch blocks, unnecessary object creation, and so forth. 
It´s possible to configure a different set of rules creating a custom XML file. 
At this point we use the default rule set to generate the alerts that we interpret as kludges and try to categorize by the algorithms described in Section \ref{alg}

\newpage

In Figure \ref{simple_code}, we can see an example of a simple code and the alerts that were generated by the default rule set of PMD alerts tool.


```{r}

saida_alg2 <- calculate_features_from_versions(
  code_file_old = "little-tree/code.java",
  code_file_new = "little-tree-new/code.java"
)



```


```{java code old simple, code=read_and_decorate_code_and_alerts("little-tree/code.java",   saida_alg2$versions_executed$pmd_output[[1]], FALSE, 10), echo = TRUE }

```


![Simple code with its alerts \label{simple_code}](figures/fake.png)


\subsection{Using PMD to generate an Abstract Syntax Tree }\label{ast}

The AST is used, in conjunction with the relation between the lines we will see in Section \ref{map}, to understand the location of an alert in a version of a code. 
We use this information in the algorithm described in Section \ref{alg2}

We can see that the tool traverses the source code visiting many different kinds of elements. 
If we build our own simple rules, aimed only to capture some kinds of elements, we will generate list of "alerts" that will contain all the elements of the chosen kinds contained in the AST.

\newpage


We don´t use all the types of nodes recognized by PMD Alert to generate the AST. The kinds of elements that were selected are the following ones:

\begin{itemize}
\item \textbf{Annotation}: a syntatic metadata added to a source code.
\item \textbf{Block}: a block of statements enclosed by braces.
\item \textbf{ClassOrInterfaceBody}: the body of an interface or a class, excluding the declaration.
\item \textbf{ClassOrInterfaceDeclaration}: class or interface, including the declaration and the body.
\item \textbf{ClassOrInterfaceType}: declaration of a type.
\item \textbf{CompilationUnit}: the root of an AST tree.
\item \textbf{ConstructorDecaration}: class or interface, including the declaration and the body.
\item \textbf{ExtendsList}: list of extensions of a class.
\item \textbf{FieldDeclaration}: field declaration, including the type, the name and the possible assignment.
\item \textbf{FormalParameter}: a parameter of a method or constructor.
\item \textbf{FormalParameters}:  list of formal parameters of a method or constructor.
\item \textbf{IfStatement}: an if statements including its blocks and condition.
\item \textbf{ImplementsList}: list of implementations of an interface.
\item \textbf{Import}: a package imported.
\item \textbf{Method}: a method, including body and declaration.
\item \textbf{Name}: a named value, like a variable, a class or a package referenced in the code.
\item \textbf{package}: the indication of the package to which the compilation unit belongs.
\item \textbf{statement}: any statement, like an if statement or an assignment.
\item \textbf{TypeDeclaration}: any type declaration.
\item \textbf{VariableId}: the name of a variable in a variable declaration.
\end{itemize}

In order to recreate the AST, we must follow three steps:

1. Link each element $a$ to the set of elements $X$ that are fully contained between the begin line / begin column and end line / end column of element $a$. 
We can construct a directed graph in which the elements are the nodes and the links described are the edges. 
This is not a tree yet, because each node will have edges directed to all its descendants and not only its children in the AST.

2. Sort the nodes in the decreasing order of its number of children. 
The objective is to establish that, in a search through this graph, the first child chosen will be the one that is a child in the AST, and not only a descendant.

3. Proceed a deep-first search starting from the compilation unit node.


\section{Algorithms to categorize alerts}\label{alg}

\subsection{Algorithm 1: Matches by line of code}\label{alg1}

In this first algorithm, I match the lines of code of the old version with the lines of code of the new version using information from the output of git's diff command. 
When an alert with the same features occurs in both matched lines, this alert is declared **open**. 
The alerts that occur in a not matched line of the old version are declared *fixed* and the alerts located in a unmatched line of the new version are declared as **new**.

These are the steps of the algorithm:

1. Generate a list of alerts from each version (old and new) using PMD Alert (Section \ref{codes});
2. Generate the git diff between the two versions (Section \ref{diff});
3. Using information from git diff, create a = map between the lines (Section \ref{map});
4. Categorize the alerts (Section \ref{categorize}).


\subsubsection{Generate a list of alerts for each version}\label{codes}




```{r execution of alerts and map, echo=FALSE  }

examples_executed <- examples %>%
    mutate(pmd_command =
               map2(
                   .x = path,
                   .y = output,
                   ~ assemble_pmd_command(
                       pmd_path = pmd_path,
                       code_path = .x ,
                       rule_path = rule_path,
                       output_path = output_path,
                       output = .y
                   )
               )) %>%
    mutate(pmd_command_output = map(
        .x = pmd_command,
        .f =  ~ system(command = .x)
    )) %>%
    mutate(pmd_output = map(.x = str_glue("{output_path}{output}.xml"), .f = read_pmd_xml))


examples_crossed <- cross_versions(examples_executed) 


```


The two codes presented in this Section, named "new version" and "old version", are used in Sections \ref{diff}, \ref{map} and \ref{categorize} to describe the algorithm.

The old version, with the alerts generated by PMI, is shown in Figure \ref{old_example}.

\newpage

\blandscape


```{java code old, code=read_and_decorate_code_and_alerts("old/code.java", examples_executed$pmd_output[[1]], TRUE, 3), echo = TRUE, size = "footnotesize" }

```

![Example: old version\label{old_example}](figures/fake.png)


\elandscape

\newpage

Table \ref{alerts_old} lists the alerts found in the old version.

```{r  show alerts old, echo=FALSE }

examples_executed$pmd_output[[1]] %>% 
  select(
    id = id_alert,
    beginline,
    ruleset,
    rule,
    package,
    class,
    method,
    variable
  ) %>% 
  replace_na(
    list(
      method = "No method",
      variable = "No variable"
    )
  ) %>% 
  kable(
    caption = "Alerts in the old version\\label{alerts_old}",
  ) %>% 
  kable_styling(
    font_size = 6,  
    latex_options = c("hold_position")
  )
  


```


The new version, shown in Figure \ref{new_example}, has the alerts listed in Table \ref{alerts_new}.

```{r  show alerts new, echo=FALSE }

examples_executed$pmd_output[[2]] %>% 
  select(
    id = id_alert,
    beginline,
    ruleset,
    rule,  
    package,
    class,
    method,
    variable
  ) %>% 
  replace_na(
    list(
      method = "No method",
      variable = "No variable"
    )
  ) %>% 
  kable(
    caption = "Alerts in the new version\\label{alerts_new}",
  ) %>% 
  kable_styling(
    font_size = 6,
    latex_options = c("hold_position")
  )
  


```

By mapping the alerts in both version, we observe the following: 

* line 3 in the old version had a "Unused Import" which was removed in the new version. 
So, the alert related to this line must be declared **fixed**;

* line 63 in the old version (61 in the new version) was fixed by changing the name of the parameter. 
This must be classified as another **fixed** alert;

* line 89 was added to the new version and contains a unused private field. 
Such must be categorized as a **new** alert.


\newpage

\blandscape

```{java new code, code=read_and_decorate_code_and_alerts("new/code.java", examples_executed$pmd_output[[2]]), echo=TRUE, size = "footnotesize" }


```

![Example: new version\label{new_example}](figures/fake.png)


\elandscape


\subsubsection{Generate the git diff between the two versions}\label{diff}

The _git diff_ command is executed between two subsequent versions with the option --patience. 
The patience algorithm works better when the changes are big. 
The result of the _git diff_ operation between the versions presented in the last section is shown in Figure \ref{figure_diff}.


```{diff showing git diff,  code=readLines("old_original_new_1.diff"), echo=TRUE}


```

![Git diff between code in Figure \ref{old_example} and code in Figure \ref{new_example} \label{figure_diff} ](figures/fake.png)


\subsubsection{Using information from git diff, create a relation between the lines}\label{map}


For each difference stated in the output (the sections of the diff file starting with "@@"), there is an indication of the number of lines removed from the old version and the number of lines added to the new one.
The line in which the lines are removed from the old version and the line at which the lines are added is indicated, too.  
By using this information we create a relation between the lines of the old version and the equivalent lines in the new version.
For the new and old versions presented in Section \ref{codes}, the relation is shown in Table \ref{table_map}.


```{r showing map  }

examples_crossed$lines_map[[1]] %>% 
  ungroup() %>% 
  mutate(
    row = row_number(),
    na_mark = if_else(is.na(map_remove) | is.na(map_add), row , NA_integer_  ),
    next_na = na_mark,
    last_na = na_mark
  ) %>% 
  fill(
    next_na, .direction = "up"
  ) %>% 
  fill(
    last_na, .direction = "down"
  ) %>% 
  replace_na(
    list(
      last_na = 0,
      next_na = nrow(examples_crossed$lines_map[[1]]) + 1
    )
  ) %>%
  mutate(
    dist_next = next_na - row,
    dist_last = row - last_na + 0.1
  ) %>%
  rowwise() %>% 
  mutate(
    min_dist = min(dist_next, dist_last)
  ) %>% 
  filter(
    min_dist < 4
  ) %>%
  ungroup() %>% 
  mutate(    
    map_remove = 
      case_when(
        min_dist == 3.1 ~ str_glue("{lag(map_remove)+1}-"),
        min_dist == 3.0 ~ str_glue("-{lead(map_remove)-1}"),
        TRUE ~ map_remove %>% as.character()
      ),
    map_add = 
      case_when(
        min_dist == 3.1 ~ str_glue("{lag(map_add)+1}-"),
        min_dist == 3.0 ~ str_glue("-{lead(map_add)-1}"),
        TRUE ~ map_add %>% as.character()
      )
  ) %>% 
  select(old = map_remove, new = map_add) %>% 
  mutate(  
    old = if_else(is.na(old), str_glue("\\textcolor{{white}}{{{row_number()}}}"), old),
    new = if_else(is.na(new), str_glue("\\textcolor{{white}}{{{row_number()}}}"), new)
  ) %>% 
  pivot_wider(
    names_from = old,
    values_from = new,
    names_repair = "minimal"
  ) %>% 
  kable(
    caption = "Relation between lines of the old version and lines of the new version\\label{table_map}",
    escape = FALSE
  ) %>% 
  kable_styling(
    font_size = ,
    latex_options = c("scale_down")
  )

```



\newpage

\blandscape


Now we can connect the two versions, as well as their alerts, as we see in Figure \ref{comparison}.



```{java showing codes, code=read_and_decorate_code_and_alerts_mapped("old/code.java", examples_executed$pmd_output[[1]], "new/code.java", examples_executed$pmd_output[[2]],examples_crossed$lines_map[[1]], TRUE, 3), echo=TRUE, size="scriptsize"  }

```

![Comparison between old and new version \label{comparison}](figures/fake.png)


\elandscape

\newpage 

\subsubsection{Categorize the alerts}\label{categorize}

The alert in the old version is classified as **open** if there is an alert in the new version in the corresponding line with the same rule, same method name, and same variable name. 
The associated rule, the name of the method and variable affected by the alert are provided by PMD Source Code Analyzer as part of the description of the alert. 
Otherwise, the alert is categorized as **fixed**.

Table \ref{class_old} shows the classification of the alerts in the old version. 
For alerts 1 and 4, it is not possible to find an alert with the same rule, method name and variable name in the related line of code in the new version. 
So, these alerts are classified as **fixed**. 
It´s easy to compare the rule, the variable name related to the alert and the method name, because all of them are outputs from the execution of PMD Source Code Analyzer. 
They are presented in the output as characteristics of the alert.

For the remaining alerts, it is possible to find an alert with the same rule, method and variable name in the related line of code in the new version. 
So, these alerts are classified as **open**.



```{r executing classifications, echo=FALSE}

classifications <- categorise_alerts(
  map = examples_crossed$lines_map[[1]], 
  alerts_old = examples_executed$pmd_output[[1]],
  alerts_new = examples_executed$pmd_output[[2]]
  ) 


```


```{r}

classifications_to_show <- classifications %>% 
  filter(version == "Old" ) %>% 
  select(
    id = id_alert_old,
    line = line_old,
    rule = rule_old,
    class = class_old,
    method = method_old,
    variable = variable_old,
    idnew = id_alert_new,
    linenew = line_new, 
    category = classification
  ) %>% 
  ungroup() %>% 
  mutate_if(
    is.character,
    ~str_replace_all(.x, "\\_", "\\\\_") 
  )

classifications_to_show %>% 
  mutate(
    category = cell_spec(x = category, format = "latex", color = if_else(category == "Fixed", "darkgreen", "darkred"))
  ) %>%
  kable(
    format = "latex",
    caption = "Classifications of the alerts in the old version \\label{class_old}",
    escape = FALSE,
    booktabs = TRUE,
    linesep = ""
  ) %>%
  kable_styling(
    font_size = 6,
    latex_options = c("hold_position", "striped")
  )
  
  


```


Table \ref{class_new} shows the classification of the alerts in the new version. 
The alert 8 is the only one for which there is no alert with the same characteristics in a line of the old version that is mapped to the original line in the new version. 
So it is the only **new** alert.


```{r}
classifications_to_show <- classifications %>% 
  filter(version == "New" ) %>% 
  select(
    id = id_alert_new,
    line = line_new,
    rule = rule_new,
    class = class_new,
    method = method_new,
    variable = variable_new,
    idold = id_alert_old,
    lineold = line_old, 
    category = classification
  ) %>% 
  ungroup() %>% 
  mutate_if(
    is.character,
    ~str_replace_all(.x, "\\_", "\\\\_") 
  )  

classifications_to_show %>% 
  filter(category == "New") %>% 
  mutate(
    category = cell_spec(x = category, format = "latex", color = if_else(category == "New", "darkorange", "darkred"))
  ) %>%
  kable(
    format = "latex",
    caption = "Classifications of the alerts in the new version \\label{class_new}",
    escape = FALSE,
    booktabs = TRUE,
    linesep = ""
  ) %>%
  kable_styling(
    font_size = 6,
    latex_options = c("hold_position", "striped")
  )
  



```




\subsection{Algorithm 2: Matches using the Abstract Syntax Tree and the relation between lines of code of the versions}\label{alg2}

This Section discusses the Algorithm 2, which uses the AST to create features that help to infer if the alerts in different versions must be considered the same. 
Nevertheless this algorithm does not return a single categorical answer for each alert (new, open or fixed), but features, it considers many cases that are ignored by the algorithm described in Section \ref{alg1}. 

The Algorithm 1 considers only the method name, the variable name, the lines of code (using git´s diff) and the type of alert. All these characteristics must be equivalent in order to two alerts be considered the same. 
For instance, if the developer changes only the name of the method but everything stays the same, the Algorithm 1 will not consider that an alert located in this renamed method is still open. 

In the Algorithm 2, many features other than "Same Method Name" will indicate that the alerts in the two versions could be the same if the only thing that changed was the name of the method.

In the Section \ref{feature_creation}, we show how the features are created. 
Even though it's not possible to be sure if a pair alerts in different versions are same alert, we think that these features can provide some clues. 
The features can be an input to a heuristic or a machine learning tool which can decide if the alerts are the same.


\subsubsection{Feature engineering} \label{feature_creation}

In this Section, we will consider the old version in Figure \ref{old_simple_code} and the new version in Figure \ref{new_simple_code}. In the new version, the alert generated by the line 11 of the old version was fixed.

\newpage

```{java code old version, code=read_and_decorate_code_and_alerts("little-tree/code.java", saida_alg2$versions_executed$pmd_output[[1]], FALSE, 20), echo = TRUE }

```


![Old version  \label{old_simple_code}](figures/fake.png)

\newpage

```{java code new version, code=read_and_decorate_code_and_alerts("little-tree-new/code.java", saida_alg2$versions_executed$pmd_output[[2]], FALSE, 20), echo = TRUE }

```


![New version  \label{new_simple_code}](figures/fake.png)

In Figure \ref{AST_compare_id_alerts} we can see both ASTs, from the old and the new version. In this figure, the number of the nodes are meaningless. We can see the alerts linked to their nodes. The Figure \ref{AST_compare} shows the kinds of nodes located near the alert that exists in both versions.

\textcolor{red}{Prof. Márcio você perguntou o significado dos números. Não é nenhum, como está dito na frase acima. Eles estão aí só para ajudar na identificação dos labels}


```{r, echo=FALSE, message=FALSE, warning=FALSE,  out.width="100%", fig.width=20, fig.height=20, fig.cap="Abstract Syntax Trees. New and old versions, with alerts \\label{AST_compare_id_alerts}", fig.pos="H"}

chart_graph_new <- show_ast(
  saida_alg2$graph_new_with_alert,
  size_label = 5,
  show_label = TRUE,
  alpha_label = 1,
  name_field = "text_alert_id_node"

)

chart_graph_old <- show_ast(
  saida_alg2$graph_old_with_alert,
  size_label = 5,
  show_label = TRUE,
  alpha_label = 1,
  name_field = "text_alert_id_node"

)



chart_graph_old + chart_graph_new


```




```{r , echo=FALSE, message=FALSE, warning=FALSE,  out.width="100%", fig.width=12, fig.height=8, fig.cap="Abstract Syntax Trees compared. New and old versions, with the type of some AST nodes \\label{AST_compare}", fig.pos="H"}



chart_graph_old <- show_ast(
  saida_alg2$graph_old_with_group, 
  size_label = 4, 
  show_label = TRUE, 
  alpha_label = "mostra", 
  title = "Old version"
) 

chart_graph_new <- show_ast(
  saida_alg2$graph_new_with_group, 
  size_label = 4, 
  show_label = TRUE, 
  alpha_label = "mostra",
  title = "New version"
)
  

chart_graph_old + chart_graph_new




```


\textcolor{red}{Prof. Márcio, a diferença entre as árvores \ref{AST_compare_id_alerts} e \ref{AST_compare}, que coloquei na legenda agora, é que uma mostra os alertas e a outra mostra os tipos de nós da AST localizados perto do alerta que ficou nas duas versões. Se colocasse tudo junto ia embolar }

In Figure \ref{AST_with_alerts} the numbers inside the nodes are the number of the group: nodes with the same number are equivalent. We define that a node from an AST is equivalent to a node of the AST of the subsequent version if:
   
- Considering the relation between the lines of the two versions constructed as we saw in Section \ref{map}, the nodes in both trees begin and end in related lines.

- The nodes are of the same kind

\textcolor{red}{Prof. Márcio, sim, agora ser o mesmo nó significa apenas estar nas mesmas linhas (levando em conta o diff) e ser do mesmo tipo. As outras carascterísticas vão ser indicadas nas features que serão construídas mais pra frente}


\textcolor{red}{Prof. Márcio, eu fui colocando várias árvores pra tentar fazer as coisas passo a passo. Apresentei primeiro os nós equivalentes e depois coloquei os alertas. Mas agora eu apresentei só uma dessas duas árvores, com uma legenda melhor }



```{r , echo=FALSE, message=FALSE, warning=FALSE,  out.width="100%", fig.width=20, fig.height=20, fig.cap="Abstract Syntax Tree. Nodes with the same number are equivalent \\label{AST_with_alerts}", fig.pos="H"}


chart_graph_old <- show_ast(
  saida_alg2$graph_old_with_alert, 
  size_label = 5, 
  show_label = TRUE, 
  alpha_label = 1, 
  node_text_field = "id_group",
  name_field = "text_alert"
  
)


chart_graph_new <- show_ast(
  saida_alg2$graph_new_with_alert, 
  size_label = 5, 
  show_label = TRUE, 
  alpha_label = 1, 
  node_text_field = "id_group",
  name_field = "text_alert"
  
)


chart_graph_old + chart_graph_new



```

The path between the alert and the root of the AST can be seen in \ref{AST_alert_1}


```{r, echo=FALSE, message=FALSE, warning=FALSE,  out.width="100%", fig.width=12, fig.height=6, fig.cap="Abstract Syntax Tree \\label{AST_alert_1}", fig.pos="H"}

show_ast(
  saida_alg2$graphs_from_alerts_old %>%  rename( id_alert = id_alert_old, graph = graph_old) %$% graph[[1]] , 
  size_label = 4
)


 


```

The algorithm generates a set of features for each pair of alerts $(n,o)$ with one element $n$ coming from the old version and one element $o$ coming from the new version. 
The features do not lead to a direct conclusion. 
It´s necessary to create a heuristic or statistical learning algorithm that will decide the final verdict based on the features.

We propose the following list of features:

* Same Rule: a boolean indicator that tells if the alerts are of the same type

* Same Group ID: a boolean indicator that tells if the alerts are equivalent as defined in Figure \ref{AST_groups}

* Same Method Group ID: a boolean indicator that tells if the alerts belong to the same method. We know the alert's method following the path from the alert´s node to the root. The first node of the kind "method" found in this path defines the alert's method. If this is the same for $o$ and for $n$, then they belong to the same method.

* Same Method Name: a boolean indicator that tells if the alerts were found in a method with the same name.

* Same Block: a boolean indicator that shows if the $o$ and $n$ belong to the same block. It is defined the same way the "Same method" indicator is defined.

* Same Code: a boolean indicator that shows the nodes that generate the alert have the same programming code.

* Same Method Code: a boolean indicator that shows that the methods that contain the nodes that generate the alert have the same programming code.

* Line distance: $o$ and $n$ have a begin line $b(o)$ and $b(n)$ and an end line $e(n)$ and $e(n)$. Line distance is $abs(mean(b(o), e(o)) - mean(b(n), e(n)))$

* Normalized line distance (block size): this is the line distance but normalized by the size of the last common node.

* Normalized line distance (method size): this is the line distance but normalized by the size of the last common method (if there is no common method, it´s normalized by the side of the compilation unit).

* Normalized line distance (compilation unit size): this is the line distance but normalized by the size of the compilation unit.

Table \ref{table_features} shows the combinations $(n,o)$ in the example. There are $2 \cdot 1 = 2$ combinations whereas we have two alerts in the old version and one alert in the new one.  


```{r}

report_features(saida_alg2, "Resulting features\\label{table_features} ")
  
```



```{r}

features_rename <- calculate_features_from_versions(
  code_file_new = "match_alerts_app/rename_method/new/code.java" ,
  code_file_old = "match_alerts_app/rename_method/old/code.java"
)

```

\newpage

\blandscape

\subsubsection{Example: Renaming method} \label{example_rename_method}

In this example, the new and old versions have only one alert. The method in which the alert happens is renamed from MethodX to methodZ.

```{java showing codes, code=read_and_decorate_code_and_alerts_mapped("match_alerts_app/rename_method/old/code.java", features_rename$versions_executed$pmd_output[[1]], "match_alerts_app/rename_method/new/code.java", features_rename$versions_executed$pmd_output[[2]],features_rename$versions_crossed$lines_map[[1]], TRUE, 20), echo=TRUE, size="scriptsize"  }
```

![Comparison between old and new version \label{comparison_rename}](figures/fake.png)

\elandscape    

\newpage 


In the Table \ref{features_rename} we can see that the features "Same Method Name" and "Same Method Group ID" are now FALSE.

```{r}

report_features(features_rename, "Resulting features: rename method example \\label{features_rename} ")


```


\newpage

\blandscape


\subsubsection{Example: including a statement before} \label{example_including_statement}


```{r}

include_statement_before <- calculate_features_from_versions(
  code_file_new = "match_alerts_app/include_statement_before/new/code.java" ,
  code_file_old = "match_alerts_app/include_statement_before/old/code.java"
)

```


In this example, a new statement is included before the alert.


```{java showing codes, code=read_and_decorate_code_and_alerts_mapped("match_alerts_app/include_statement_before/old/code.java", include_statement_before$versions_executed$pmd_output[[1]], "match_alerts_app/include_statement_before/new/code.java", include_statement_before$versions_executed$pmd_output[[2]],include_statement_before$versions_crossed$lines_map[[1]], TRUE, 20), echo=TRUE, size="scriptsize"  }
```

![Comparison between old and new version \label{comparison_include_statement_before}](figures/fake.png)

\elandscape    

\newpage 


In the Table \ref{include_statement_before} we can see that the features are not affected by this new statement.

```{r}

report_features(include_statement_before, "Resulting features: statement included before \\label{include_statement_before} ")


```

\newpage

\blandscape


\subsubsection{Example: nesting the alert in an if statement} \label{example_nested_in_other_if}

```{r}

nested_in_other_if <- calculate_features_from_versions(
  code_file_new = "match_alerts_app/nested_in_other_if/new/code.java" ,
  code_file_old = "match_alerts_app/nested_in_other_if/old/code.java"
)

```



```{java showing codes, code=read_and_decorate_code_and_alerts_mapped("match_alerts_app/nested_in_other_if/old/code.java", nested_in_other_if$versions_executed$pmd_output[[1]], "match_alerts_app/nested_in_other_if/new/code.java", nested_in_other_if$versions_executed$pmd_output[[2]],nested_in_other_if$versions_crossed$lines_map[[1]], TRUE, 20), echo=TRUE, size="scriptsize"  }
```

![Comparison between old and new version \label{comparison_nested_in_other_if}](figures/fake.png)

\elandscape    

\newpage 


In the Table \ref{nested_in_other_if} we can see that the algorithm does not recognize the two nodes as equivalent, but other features can lead us to the conclusion that the alert is still open.

```{r}

report_features(nested_in_other_if, "Resulting features: statement included before \\label{nested_in_other_if} ")


```


\newpage

\blandscape


\subsubsection{Example: editing the line that generates the alert} \label{example_editing_line}

```{r}

editing_line <- calculate_features_from_versions(
  code_file_new = "match_alerts_app/editing_line/new/code.java" ,
  code_file_old = "match_alerts_app/editing_line/old/code.java"
)

```




```{java showing codes, code=read_and_decorate_code_and_alerts_mapped("match_alerts_app/editing_line/old/code.java", editing_line$versions_executed$pmd_output[[1]], "match_alerts_app/editing_line/new/code.java", editing_line$versions_executed$pmd_output[[2]],editing_line$versions_crossed$lines_map[[1]], TRUE, 20), echo=TRUE, size="scriptsize"  }
```


![Comparison between old and new version \label{comparison_editing_line}](figures/fake.png)

\elandscape    

\newpage


In the Table \ref{editing_line} the nodes are not recognized as equivalent, but other features can lead us to the conclusion that the alert is still open.

```{r}

report_features(editing_line, "Resulting features: alert line edited \\label{editing_line} ")


```

\newpage

\blandscape


\subsubsection{Example: changing the order of the methods} \label{example_editing_line}


We changed the order of the methods in two ways


```{r}

changing_method_order <- calculate_features_from_versions(
  code_file_new = "match_alerts_app/changing_method_order/new/code.java" ,
  code_file_old = "match_alerts_app/changing_method_order/old/code.java"
)

```


```{java showing codes, code=read_and_decorate_code_and_alerts_mapped("match_alerts_app/changing_method_order/old/code.java", changing_method_order$versions_executed$pmd_output[[1]], "match_alerts_app/changing_method_order/new/code.java", changing_method_order$versions_executed$pmd_output[[2]],changing_method_order$versions_crossed$lines_map[[1]], TRUE, 20), echo=TRUE, size="scriptsize"  }
```


![Comparison between old and new version \label{comparison_changing_method_order}](figures/fake.png)

\elandscape    

\newpage

In the Table \ref{changing_method_order} the nodes are not recognized as equivalent, but other features can lead us to the conclusion that the alert is still open.

```{r}

report_features(changing_method_order, "Resulting features: changed methods order \\label{changing_method_order} ")


```

\newpage

\blandscape




```{r}

changing_method_order_2 <- calculate_features_from_versions(
  code_file_new = "match_alerts_app/changing_method_order_2/new/code.java" ,
  code_file_old = "match_alerts_app/changing_method_order_2/old/code.java"
)

```


```{java showing codes, code=read_and_decorate_code_and_alerts_mapped("match_alerts_app/changing_method_order_2/old/code.java", changing_method_order_2$versions_executed$pmd_output[[1]], "match_alerts_app/changing_method_order_2/new/code.java", changing_method_order_2$versions_executed$pmd_output[[2]],changing_method_order_2$versions_crossed$lines_map[[1]], TRUE, 20), echo=TRUE, size="scriptsize"  }
```


![Comparison between old and new version \label{comparison_changing_method_order_2}](figures/fake.png)

\elandscape    

\newpage




In the Table \ref{changing_method_order_2} the nodes are not recognized as equivalent, but other features can lead us to the conclusion that the alert is still open.

```{r}

report_features(changing_method_order_2, "Resulting features: changed methods order 2 \\label{changing_method_order_2} ")


```







