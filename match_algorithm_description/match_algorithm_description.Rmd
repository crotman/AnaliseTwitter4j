---
title: "Match algorithm description"
author: "Bruno Crotman"
date: "18/04/2020"
header-includes:
  - \usepackage{lscape}
  - \newcommand{\blandscape}{\begin{landscape}}
  - \newcommand{\elandscape}{\end{landscape}}  
  - \definecolor{darkred}{RGB}{150, 40, 40}
  - \definecolor{darkgreen}{RGB}{30, 120, 30}
  - \definecolor{darkorange}{RGB}{40, 40, 160}
output: 
    pdf_document:
        number_sections: true
        fig_caption: true

---



```{r setup, include=FALSE}

library(xml2)
library(tidyverse)
library(gt)
library(knitr)
library(kableExtra)
library(tidygraph)
library(ggraph)

knitr::opts_chunk$set(echo = FALSE, size = "small", warning = FALSE, message = FALSE, cache = FALSE)

def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})


source("functions.r", encoding = "UTF-8") 


```

\section{Introduction}\label{intro}

This document is part of a bigger project. The project is a research about software degradation caused by careless developers' behavior and strategies to deal with it. The strategies to deal with the problem will possibly be inspired by concepts from game theory. At this moment, we think that software degradation can be measured by the number and the types of kludges made by software developers in the code. So, one of the goals of this project at this moment is to study how software projects evolve in terms of number of kludges and kinds of kludges.

Right now we are trying to identify kludges looking at alerts generated by PMD source code analyzer. This tool receives a programming code as input and generates a list of bad programming practices contained in the code.

In order to evaluate how the number of alerts is evolving along the history of a software project, we must be able to analyze two different versions of a code (an old version and a new version) and cateborize each alert as **new**, **fixed** or **not fixed**.

* each PMD alert generated for the old version is either **not fixed** or **fixed** in the new version. When an alert is **not fixed**, it means that it remains in the new version of the code. When an alert is **fixed**, it means that it does not exist anymore in the new version.

* each PMD alert generated for the new version is **not fixed** or **new**. When an alert is **not fixed** it means that the same alert was identified in the old version. When an alert is **new**, it means that the same alert cannot be identified in the old version.

The alerts identified as *not fixed* are the equivalent in both new and old versions. And the intersection between the *fixed* alerts, the *new* alerts and the *not fixed* alerts is empty.

In order to decide if an alert is *not fixed*, *fixed* or *new*, we have to identify if an alert in the old version is equivalent to an alert in the new version.

I describe here two algorithms. The first one, described in Section \ref{alg1}, is a naive algorithm based on matches by lines of code and some characteristics of the alert. The second is a more sophisticated algorithm, based on matches by blocks of code, using the Abstract Syntax Code.

\section{Matches by line of code}\label{alg1}

In this first algorithm, I match the lines of code of the old version with the lines of code of the new version using information from the output of git's diff command. When an alert with the same features occurs in both matched lines, this alert is declared *not fixed*. The alerts that occur in a not matched line of the old version are declared *fixed* and the alerts located in a not matched line of the new version are declared *new*

These are the steps of the algorithm:

1. Generate a list of alerts from each version (old and new) using PMD Alert (Section \ref{codes});
1. Generate the git diff between the two versions (Section \ref{diff});
2. Using information from git diff, create a relation between the lines (Section \ref{map});
3. Categorize the alerts (Section \ref{categorize}).


\subsection{Generate a list of alerts for each version}\label{codes}


```{r definitions, echo=FALSE}

size_line_of_code <- 160

length_alert_name <- 35

length_alert_name_side_by_side <- 20

size_line_of_code_side_by_side <- 110


pmd_path <- "C:\\doutorado\\AnaliseTwitter4j\\pmd\\bin\\pmd.bat"

rule_path <- "rulesets/java/quickstart.xml"

output_path <-  "C:\\doutorado\\AnaliseTwitter4j\\match_algorithm_description\\"  

examples <- tribble(
    
    ~name,                  ~path,                                                              ~output,          
    "Versão Old Original",  "C:\\doutorado\\AnaliseTwitter4j\\match_algorithm_description\\old" ,  "old_original",
    "Versão New 1",         "C:\\doutorado\\AnaliseTwitter4j\\match_algorithm_description\\new",   "new_1"
    
) %>% 
    mutate(id = row_number())

```


```{r execution of alerts and map, echo=FALSE  }


examples_executed <- examples %>%
    mutate(pmd_command =
               map2(
                   .x = path,
                   .y = output,
                   ~ assemble_pmd_command(
                       pmd_path = pmd_path,
                       code_path = .x ,
                       rule_path = rule_path,
                       output_path = output_path,
                       output = .y
                   )
               )) %>%
    mutate(pmd_command_output = map(
        .x = pmd_command,
        .f =  ~ shell(cmd = .x, shell = "PowerShell")
    )) %>%
    mutate(pmd_output = map(.x = str_glue("{output_path}{output}.xml"), .f = read_pmd_xml))

examples_executed_selected_fields_left <-
    examples_executed %>% select(id, name, path, output) %>%
    rename_all(
        .funs = function(x) {
            str_glue("{x}_left")
        }
    )

examples_executed_selected_fields_right <-
    examples_executed %>% select(id, name, path, output) %>%
    rename_all(
        .funs = function(x) {
            str_glue("{x}_right")
        }
    )


examples_crossed <- examples_executed_selected_fields_left %>%
    crossing(examples_executed_selected_fields_right) %>%
    filter(id_left < id_right) %>%
    mutate(diff_command =
               map2(
                   .x = path_left,
                   .y = path_right,
                   ~ assemble_diff_command(
                       code_path_left = .x,
                       code_path_right = .y,
                       output_path = output_path,
                       output_left = output_left,
                       output_right = output_right
                   )
               )) %>%
    mutate(lines_left = read_number_of_lines(path_left),
           lines_right = read_number_of_lines(path_right)) %>%
    mutate(
        output_diff_command = map(
            .x = diff_command,
            .f = ~ shell(cmd = .x, shell = "PowerShell")
        ),
        file_diff = str_glue("{output_path}{output_left}_{output_right}.diff")
    ) %>%
    mutate(lines_map = pmap(
        .l = list(
            file = file_diff  ,
            lines_prev_param = lines_left,
            lines_post_param = lines_right
        ),
        .f = map_lines
    ))



```


The two codes presented in this Section, named "new version" and "old version", are used in Sections \ref{diff}, \ref{map} and \ref{categorize} to describe the algorithm.

The old version, with the alerts generated by PMI, is shown in Figure \ref{old_example}.

\textcolor{red}{Prof. Márcio: Tem como reduzir a fonte para que o label da Figura \ref{old_example} caiba na página?}

\textcolor{red}{Bruno: Feito}

\newpage

\blandscape


```{java code old, code=read_and_decorate_code_and_alerts("old/code.java", examples_executed$pmd_output[[1]], TRUE, 3), echo = TRUE, size = "footnotesize" }

```

![Example: old version\label{old_example}](figures/fake.png)


\elandscape

\newpage

Table \ref{alerts_old} lists the alerts found in the old version.

```{r  show alerts old, echo=FALSE }

examples_executed$pmd_output[[1]] %>% 
  select(
    id = id_alert,
    beginline,
    ruleset,
    rule,
    package,
    class,
    method,
    variable
  ) %>% 
  replace_na(
    list(
      method = "No method",
      variable = "No variable"
    )
  ) %>% 
  kable(
    caption = "Alerts in the old version\\label{alerts_old}",
  ) %>% 
  kable_styling(
    font_size = 6,  
    latex_options = c("hold_position")
  )
  


```


The new version (Figure \ref{new_example}) has the following changes in relation to the old version: 

* line 3 of the old version "import java.util.concurrent.ConcurrentHashMap", that was a "Unused Import", was removed. So the alert related to this line must be declared *fixed*.
* line 63 of the old version (61 of the new version) was fixed by changing the name of the parameter. This must be classified as another *fixed* alert.
* line 89 was included in the new version, with an unused private field. This must be categorized as a *new* alert

\textcolor{red}{Prof. Márcio: As linhas 92 e 119 não aparecem nas Figuras 1 e 2, nem nas tabelas que as seguem. Assim, você não consegue comparar o antes e o depois.}

\textcolor{red}{Bruno: Esses números estavam todos errados. Troquei o código tirando umas coisas inúteis pra ver se cabia e esqueci de mudar. Essa parte não está automática}




\newpage

\blandscape

```{java new code, code=read_and_decorate_code_and_alerts("new/code.java", examples_executed$pmd_output[[2]]), echo=TRUE, size = "footnotesize" }


```

![Example: new version\label{new_example}](figures/fake.png)


\elandscape

Table \ref{alerts_new} lists the alerts found in the new version.

```{r  show alerts new, echo=FALSE }

examples_executed$pmd_output[[2]] %>% 
  select(
    id = id_alert,
    beginline,
    ruleset,
    rule,
    package,
    class,
    method,
    variable
  ) %>% 
  replace_na(
    list(
      method = "No method",
      variable = "No variable"
    )
  ) %>% 
  kable(
    caption = "Alerts in the new version\\label{alerts_new}",
  ) %>% 
  kable_styling(
    font_size = 6,
    latex_options = c("hold_position")
  )
  


```


    
\subsection{Generate the git diff between the two versions}\label{diff}

The command git diff is executed between the two versions with the option --patience. 

The result of the git diff operation between these two versions is shown in Figure \ref{figure_diff}.


```{diff showing git diff,  code=readLines("old_original_new_1.diff"), echo=TRUE}


```

![Git diff between code in Figure \ref{old_example} and code in Figure \ref{new_example} \label{figure_diff} ](figures/fake.png)


\subsection{Using information from git diff, create a relation between the lines}\label{map}


Using this information from git's diff, it's possible to create a relation between the lines of the old version and the new version.

For each difference stated in the git diff output (the sections of the diff file starting with "@@"), there is an indication of the number of lines removed from the old version and the number of lines added to the new version. The line in which the lines are removed from the old version and the line at which the lines are added is indicated, too.  Following this information it´s possible to create a relation between the lines of the old version and the equivalent lines in the new version.

For the new and old versions presented in Section \ref{codes}, the relation is shown in Table \ref{table_map}

\textcolor{red}{Prof. Márcio: Eu usaria "a relation" ao invés de "a map".}
\textcolor{red}{Bruno: troquei para relation em todo o texto.}


\textcolor{red}{Prof. Márcio: colocar a  tabela \ref{table_map} de forma horizontal.}
\textcolor{red}{Bruno: OK.}


```{r showing map  }

examples_crossed$lines_map[[1]] %>% 
  ungroup() %>% 
  mutate(
    row = row_number(),
    na_mark = if_else(is.na(map_remove) | is.na(map_add), row , NA_integer_  ),
    next_na = na_mark,
    last_na = na_mark
  ) %>% 
  fill(
    next_na, .direction = "up"
  ) %>% 
  fill(
    last_na, .direction = "down"
  ) %>% 
  replace_na(
    list(
      last_na = 0,
      next_na = nrow(examples_crossed$lines_map[[1]]) + 1
    )
  ) %>%
  mutate(
    dist_next = next_na - row,
    dist_last = row - last_na + 0.1
  ) %>%
  rowwise() %>% 
  mutate(
    min_dist = min(dist_next, dist_last)
  ) %>% 
  filter(
    min_dist < 4
  ) %>%
  ungroup() %>% 
  mutate(    
    map_remove = 
      case_when(
        min_dist == 3.1 ~ str_glue("{lag(map_remove)+1}-"),
        min_dist == 3.0 ~ str_glue("-{lead(map_remove)-1}"),
        TRUE ~ map_remove %>% as.character()
      ),
    map_add = 
      case_when(
        min_dist == 3.1 ~ str_glue("{lag(map_add)+1}-"),
        min_dist == 3.0 ~ str_glue("-{lead(map_add)-1}"),
        TRUE ~ map_add %>% as.character()
      )
  ) %>% 
  select(old = map_remove, new = map_add) %>% 
  mutate(  
    old = if_else(is.na(old), str_glue("\\textcolor{{white}}{{{row_number()}}}"), old),
    new = if_else(is.na(new), str_glue("\\textcolor{{white}}{{{row_number()}}}"), new)
  ) %>% 
  pivot_wider(
    names_from = old,
    values_from = new,
    names_repair = "minimal"
  ) %>% 
  kable(
    caption = "Relation between lines of the old version and lines of the new version\\label{table_map}",
    escape = FALSE
  ) %>% 
  kable_styling(
    font_size = ,
    latex_options = c("scale_down")
  )

```



\newpage

\blandscape


Now we can connect the two versions and plugin the alerts as we see in Figure \ref{comparison}.



```{java showing codes, code=read_and_decorate_code_and_alerts_mapped("old/code.java", examples_executed$pmd_output[[1]], "new/code.java", examples_executed$pmd_output[[2]],examples_crossed$lines_map[[1]], TRUE, 3), echo=TRUE, size="tiny"  }

```

![Comparison between old and new version \label{comparison}](figures/fake.png)


\elandscape

\newpage 

\subsection{Categorize the alerts}\label{categorize}

\textcolor{red}{Prof. Márcio: Faltou este passo no algoritmo que você colocou no início da seção 2.}

\textcolor{red}{Bruno: Foi citado agora.}

\textcolor{red}{Prof. Márcio: Parece que você mudou do algoritmo naïve para o algoritmo mais complexo aqui. Está usando infromações de métodos, regras e nomes de variáveis ao invés de apenas linhas de código. Foi isto mesmo? Como as variáveis e métodos são identificados?.}

\textcolor{red}{Bruno: Na verdade minha ideia de naive já inclui utilizar as linhas e as características principais do alerta: tipo de alerta, nome da variável afetada e nome do método onde o alerta está. O que ele não usa é toda a AST. Eu reforcei isso sobre io algoritmo naive na seção \ref{intro}, mas já estava escrito na seção \ref{alg1} que "When an alert with the same features occurs in both matched lines, this alert is declared *not fixed*" }


The alert in the old version is classified as **not fixed** if there is an alert in the new version in the corresponding line with the same rule, same method name and same variable name. Otherwise, the alert is categorised as **fixed**

Table \ref{class_old} shows the classification of the alerts in the old version. For alerts 1 and 4, it is not possible to find an alert with the same rule, same method name and same variable name in a new version's line that is mapped to the line in the old version. So these alerts are classified as **fixed**. 

For each other alert, it is possible to find an alert with the same rule, same method name and same variable name in the new version's line that is mapped to the original line. So these alerts are classified as **not fixed**.

```{r executing classifications, echo=FALSE}

classifications <- categorise_alerts(
  map = examples_crossed$lines_map[[1]], 
  alerts_old = examples_executed$pmd_output[[1]],
  alerts_new = examples_executed$pmd_output[[2]]
  ) 


```


```{r}

classifications_to_show <- classifications %>% 
  filter(version == "Old" ) %>% 
  select(
    id = id_alert_old,
    line = line_old,
    rule = rule_old,
    class = class_old,
    method = method_old,
    variable = variable_old,
    idnew = id_alert_new,
    linenew = line_new, 
    category = classification
  ) %>% 
  ungroup() %>% 
  mutate_if(
    is.character,
    ~str_replace_all(.x, "\\_", "\\\\_") 
  )

classifications_to_show %>% 
  mutate(
    category = cell_spec(x = category, format = "latex", color = if_else(category == "Fixed", "darkgreen", "darkred"))
  ) %>%
  kable(
    format = "latex",
    caption = "Classifications of the alerts in the old version \\label{class_old}",
    escape = FALSE,
    booktabs = TRUE,
    linesep = ""
  ) %>%
  kable_styling(
    font_size = 6,
    latex_options = c("hold_position", "striped")
  )
  
  


```




Table \ref{class_new} shows the classification of the alerts in the new version. The alert 8 is the only one for which there is no alert with the same characteristics in a line of the old version that is mapped to the original line in the new version. So it is the only **new** alert.



```{r}
classifications_to_show <- classifications %>% 
  filter(version == "New" ) %>% 
  select(
    id = id_alert_new,
    line = line_new,
    rule = rule_new,
    class = class_new,
    method = method_new,
    variable = variable_new,
    idold = id_alert_old,
    lineold = line_old, 
    category = classification
  ) %>% 
  ungroup() %>% 
  mutate_if(
    is.character,
    ~str_replace_all(.x, "\\_", "\\\\_") 
  )  

classifications_to_show %>% 
  mutate(
    category = cell_spec(x = category, format = "latex", color = if_else(category == "New", "darkorange", "darkred"))
  ) %>%
  kable(
    format = "latex",
    caption = "Classifications of the alerts in the new version \\label{class_new}",
    escape = FALSE,
    booktabs = TRUE,
    linesep = ""
  ) %>%
  kable_styling(
    font_size = 6,
    latex_options = c("hold_position", "striped")
  )
  



```




\section{Matches using the Abstract Syntax Tree and the relation between lines of code of the versions}



\subsection{Creating an Abstract Syntax Tree}


The Abstract Syntax Tree (AST) of a source code contains the elements represented in the code, such as class declarations, method declarations, statements. The AST can be used, in conjunction with the relation between the lines we saw in Section \ref{map}, to understand the location of an alert in a version of a code.

The PMD Alert tool lets us configure our own rules. In section \ref{codes} we generated alerts using the default configuration of alerts.

The alerts that PMD generates are elements that the tool captures as it traverses the code, visiting all the elements of the AST. An element is captured and becomes an alert when it is matched with a rule. The rules are defined in a XML file.

\textcolor{red}{Prof. Márcio Este tipo de informação deveria vir no início do texto. Você já tratou com alertas identificados antes ...}

\textcolor{red}{Bruno: É que aqui estou explicando como eu uso o mecanismo de geração de alertas pra gerar a AST. Mas vou pensar na melhor forma de dividir essas coisas no texto}


\newpage

In Figure \ref{simple_code}, we can see an example of a simple code and the alerts that were generated by the default ruleset of PMD alerts tool. 


```{r}


examples_sec2 <- tribble(
    
    ~name,                  ~path,                                                              ~output,          
    "Simple old",  "C:\\doutorado\\AnaliseTwitter4j\\match_algorithm_description\\little-tree" ,  "little_tree_old",

) %>% 
    mutate(id = row_number())


examples_sec2_executed <- examples_sec2 %>%
    mutate(pmd_command =
               map2(
                   .x = path,
                   .y = output,
                   ~ assemble_pmd_command(
                       pmd_path = pmd_path,
                       code_path = .x ,
                       rule_path = rule_path,
                       output_path = output_path,
                       output = .y
                   )
               )) %>%
    mutate(pmd_command_output = map(
        .x = pmd_command,
        .f =  ~ shell(cmd = .x, shell = "PowerShell")
    )) %>%
    mutate(pmd_output = map(.x = str_glue("{output_path}{output}.xml"), .f = read_pmd_xml))


```


```{java code old simple, code=read_and_decorate_code_and_alerts("little-tree/code.java", examples_sec2_executed$pmd_output[[1]], FALSE, 10), echo = TRUE }

```


![Simple code with its alerts \label{simple_code}](figures/fake.png)


It's possible to create custom rules for PMD. Figure \ref{pmd_designer_fig} shows the designer tool that helps a user to create custom rules.

![PMD Designer tool\label{pmd_designer_fig}](figures/pmddesigner.png)

We can see that the tool traverses the programming code visiting many different kinds of elements. If we build our own simple rules, aimed only to capture some kinds of elements, we will generate list of "alerts" that will contain all the elements of the chosen kinds.

\newpage

In Figure \ref{ruleset}, we show an example of a ruleset that captures all the method declarations.

```{xml, code=read_lines("blockrules/extractblockrules.xml"), echo = TRUE }

```

![Custom ruleset for PMD alerts tool \label{ruleset}](figures/fake.png)



Table \ref{selected_nodes} shows the kinds of elements that were selected for the creation of an AST for the code in Figure \ref{simple_code}.


```{r}

map_rule_small <- tribble(
    
    ~rule,                              ~small_rule,
    "class_or_interface_body",          "class_body",                   
    "class_or_interface_declaration",   "class_decl",
    "class_or_interface_type",          "class_type",
    "compilation_unit",                 "unit",
    "extends_list",                     "extends",
    "implements_list",                  "implements",
    "import_declaration",               "import",
    "method",                           "method",
    "name",                             "name",
    "package",                          "package",
    "type_declaration",                 "type_decl",
    "constructor_declaration",          "constructor",
    "field_declaration",                "field",
    "variable_id",                      "var_id",
    "formal_parameter",                 "param",
    "formal_parameters",                "params",
    "annotation",                       "annotation",
    "block",                            "block",
    "statement",                        "statement",
    "if_statement",                     "if"

)



map_rule_small %>%
  arrange(
    rule
  ) %>% 
  mutate(
    rule_number = row_number()
  ) %>%
  select(rule_number, rule) %>%
  kable(
    format = "latex",
    caption = "Kinds of elements selected\\label{selected_nodes}",
    escape = TRUE
  ) %>%
  kable_styling(
    font_size = 8,
    latex_options = c("hold_position", "striped")
  )
  


```


If we select the list in Table \ref{selected_nodes}, the simple code shown in this Section captures the elements shown in Table \ref{elements_captured}    


```{r}

shell(r"(C:\doutorado\AnaliseTwitter4j\pmd\bin/pmd.bat -d C:\doutorado\AnaliseTwitter4j\match_algorithm_description\little-tree -f xml -R C:\doutorado\AnaliseTwitter4j\match_algorithm_description\blockrules\blockrules.xml -reportfile C:\doutorado\AnaliseTwitter4j\match_algorithm_description\oldblock.xml)")


code_all_lines <- read_lines("little-tree/code.java")

alerts <- read_pmd_xml("oldblock.xml") %>% 
    replace_na(
        list(
            method = "No method"
        )
    ) %>% 
    left_join(
        map_rule_small,
        by = c("rule")
    ) %>% 
    mutate(
        code = pmap(
            .l =  list(
                strings_param = str_flatten(code_all_lines, collapse = "\n"), 
                begin_line = beginline, 
                end_line = endline, 
                begin_column = begincolumn, 
                end_column = endcolumn                
            ),
            .f = extract_piece_of_code 
        )
    )


alerts %>%
  select(
    -c(linha, ruleset, package, class, priority, variable, id_alert, small_rule)
  ) %>% 
  rename(
    line = beginline,
    endline = endline,
    col = begincolumn,
    endcol = endcolumn
    
  ) %>% 
  mutate(
    code = str_trunc(code,width = 30, ellipsis = "...")
  ) %>% 
  arrange(
    line, col
  ) %>% 
  kable(
    format = "latex",
    caption = "Elements captured in code\\label{elements_captured}",
    escape = TRUE
  ) %>%
  kable_styling(
    font_size = 8,
    latex_options = c("hold_position")
  )




```


Table \ref{selected_nodes} contains the list and location of the elements of the AST. In order to recreate the AST, we must follow three steps:

1. Link each element $a$ to the set of elements $X$ that are fully located between the begin line / begin column and end line / end column of element $a$. We can construct a directed graph in which the elements are the nodes and the links are the edges. This is not a tree yet, because each node will have edges directed to all its descendents and not only its children in the AST.

2. Sort the nodes in the decreasing order of its number of childs. The objective is to establish that, in a search through this graph, the first child chosen will be the one that is a child in the AST, and not only on this graph.

3. Proceed a deep-first search starting from the compilation unit node.

\newpage

After we follow these steps, we come up with the AST as we se in Figure \ref{AST}.


```{r, echo=FALSE, message=FALSE, warning=FALSE,  out.width="100%", fig.width=12, fig.height=16, fig.cap="Abstract Syntax Tree \\label{AST}" }

max_column <- max(alerts$endcolumn)

alerts_from <- alerts %>%  rename_all(.funs = ~str_glue("{.x}_from"))

alerts_to <- alerts %>%  rename_all(.funs = ~str_glue("{.x}_to"))

all_edges <- alerts_from %>% 
    crossing(alerts_to) %>% 
    mutate(
        location_begin_from = beginline_from * max_column + begincolumn_from,
        location_begin_to = beginline_to * max_column + begincolumn_to,
        location_end_from = endline_from * max_column + endcolumn_from,
        location_end_to = endline_to * max_column + endcolumn_to
    ) %>% 
    filter(id_alert_from != id_alert_to) %>% 
    filter(
        location_begin_from <= location_begin_to & location_end_from >= location_end_to
    ) %>% 
    select(
        from = id_alert_from,
        to =id_alert_to
    ) 


descendents <- all_edges %>% 
    group_by(from) %>% 
    summarise(n_descendents = n()) 

alerts_sorted <- alerts %>% 
    left_join(
        descendents,
        by = c("id_alert" = "from")
    ) %>% 
    replace_na(
        list(n_descendents = 0 )
    ) %>% 
    arrange(
        desc(n_descendents)
    ) %>% 
    mutate(
        id_alert_old = id_alert,
        id_alert = row_number()
    ) %>%  
    mutate(
        name = case_when(
            small_rule %in% c("name", "class_type","var_id" ) ~ str_glue('{id_alert}:{small_rule}:{code}'),
            TRUE ~ str_glue("{id_alert}:{small_rule}")
        )
    )

map_new_id_alert <- alerts_sorted %>% 
    select(
        id_alert_old,
        id_alert
    )

all_edges_new_id <-  all_edges %>% 
    left_join(
        map_new_id_alert,
        c("from" = "id_alert_old")
    ) %>% 
    mutate(
        from = id_alert
    ) %>% 
    select(-id_alert) %>% 
    left_join(
        map_new_id_alert,
        c("to" = "id_alert_old")
    ) %>% 
    mutate(
        to = id_alert
    ) %>% 
    select(-id_alert) 
    
complete_graph <- create_empty(n = 0, directed = TRUE) %>% 
    bind_nodes(alerts_sorted ) %>% 
    bind_edges(all_edges_new_id) 


graph_dfs_tree <- complete_graph %>% 
    convert(to_dfs_tree , root = 1, mode = "out" )
    

edges <- graph_dfs_tree %>% 
    activate(edges)


ggraph(graph_dfs_tree, layout = "tree" ) +
    geom_edge_link(arrow = arrow(length = unit(2, 'mm')), 
                   end_cap = circle(2, 'mm')) +    
    geom_node_label(
        aes(label = name),
        label.size = 0.3,
        repel = TRUE,
        size = 5.5,
        label.padding = 0.3
    ) +
    geom_node_point(
        aes(color = method),
        size = 8
    ) +
    geom_node_text(
       aes(label = id_alert),
       size = 5
    ) +
    coord_flip() +
    scale_x_reverse(expand =c(-1.2,1.2)) +
    scale_y_continuous(expand =c(-1.2,1.2)) +
    theme_void() +
    theme(
        aspect.ratio = 1.3  ,
        legend.position = "top" 
    )




```

\newpage

\textcolor{red}{Prof. Márcio: OK, mas cadê o algoritmo
para classificar os alertas}

\textcolor{red}{Bruno: eu ainda não fiz isso, mesmo. Mas vai ser mais ou menos o seguinte, só preciso fazer umas experiências e organizar melhor: vou partir do que faço no naive, mas, para os alertas que não baterem, vou tentar subir na AST em direção à raiz e ver se num nó num nível acima as coisas batem (o nó da árvore tem que bater com o nó da outra árvore via match de linha e tipo de nó, e tem que bater também as características do alerta), depois posso subir de novo, se não der... Só tem que pensar bem porque tem duas árvores, e alertas subindo pelas duas árvores. Tenho que experimentar agora que já consigo montar as árvores e tal. testar uns exemplos e ver o que acontece. Consegui me familiarizar com umas bibliotecas do R que ajudam a manipular e plotar grafos (tidygraph e ggraph). Tem um trade-off entre complexidade do algoritmo e a quantidade de falsos negativos que ele vai dar por não bater alertas que deveriam bater. Não vou esgotar isso agora, mas quero organizar UM POUCO essas ideias e mostrar esses recursos da AST pra ajudar o Earl e vc a pensarem comigo}




